<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Core.ServiceClasses</name>
    </assembly>
    <members>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable">
            <summary>
            Структура поддержки смены контекста
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable.#ctor(Core.ServiceClasses.AsyncAwaitSupport.IContextSwitchSupplier)">
            <summary>
            Конструктор для случая внешней смены контектса
            </summary>
            <param name="supplier">Поставщик смены контекста</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable.#ctor(System.Threading.SynchronizationContext)">
            <summary>
            Конструктор, принимающий целевой контекст синхронизации
            </summary>
            <param name="targetContext">Целевой контекст синхронизации</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable.GetAwaiter">
            <summary>
            Получение объекта ожидания смены контекста
            </summary>
            <returns>Объект ожидания</returns>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable.ContextSwitchAwaiter">
            <summary>
            Структура ожидания смены контекста
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable.ContextSwitchAwaiter.#ctor(Core.ServiceClasses.AsyncAwaitSupport.IContextSwitchSupplier)">
            <summary>
            Конструктор, принимающий операцию, которя сменит контекст
            </summary>
            <param name="supplier">Поставщик контекста</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable.ContextSwitchAwaiter.GetResult">
            <summary>
            Получение результата (ничего не делает, т.к. просто меняем контектс)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable.ContextSwitchAwaiter.OnCompleted(System.Action)">
            <summary>
            Собственно смена контекста
            </summary>
            <param name="continuation">Продолжение, которое будет выполнено в новом контектсе</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable.ContextSwitchAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>
            Смена контекста без протаскивания данных текущего контекста.
            </summary>
            <param name="continuation">Продолжение, которое будет выполнено в новом контектсе</param>
        </member>
        <member name="P:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchAwaitable.ContextSwitchAwaiter.IsCompleted">
            <summary>
            Завершена ли операция синхронно (всегда false)
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.IContextSwitchSupplier">
            <summary>
            Поставщик смены контекста исполнения (смены потока, а не ExecutionContext)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.IContextSwitchSupplier.Run(System.Action,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.IContextSwitchSupplier.RunWithState(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="state">Состояние</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.IContextSwitchSupplierCodeContractCheck">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.IContextSwitchSupplierCodeContractCheck.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.IContextSwitchSupplierCodeContractCheck.Run(System.Action,System.Boolean)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.IContextSwitchSupplierCodeContractCheck.RunWithState(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.CustomSynchronizationContext">
            <summary>
            Контекст синхронизации
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.CustomSynchronizationContext.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.CustomSynchronizationContext.#ctor(Core.ServiceClasses.AsyncAwaitSupport.ICustomSynchronizationContextSupplier)">
            <summary>
            Конструктор контекста синхронизации
            </summary>
            <param name="supplier">Объект-исполнитель действий</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.CustomSynchronizationContext.CreateCopy">
            <summary>
            Создание копии
            </summary>
            <returns>Копия</returns>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.CustomSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Синхронный запуск задания
            </summary>
            <param name="d">Задание</param>
            <param name="state">Параметр</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.CustomSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Асинхронный запуск задания
            </summary>
            <param name="d">Задание</param>
            <param name="state">Параметр</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.ICustomSynchronizationContextSupplier">
            <summary>
            Поставщик синхронизации
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ICustomSynchronizationContextSupplier.RunAsync(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Асинхронное выполнение задания
            </summary>
            <param name="act">Задание</param>
            <param name="state">Состояние</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ICustomSynchronizationContextSupplier.RunSync(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Синхронное выполнение задание
            </summary>
            <param name="act">Задание</param>
            <param name="state">Состояние</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.ICustomSynchronizationContextSupplierCodeContractCheck">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ICustomSynchronizationContextSupplierCodeContractCheck.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ICustomSynchronizationContextSupplierCodeContractCheck.RunAsync(System.Threading.SendOrPostCallback,System.Object)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ICustomSynchronizationContextSupplierCodeContractCheck.RunSync(System.Threading.SendOrPostCallback,System.Object)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler">
            <summary>
            Планировщик задач с лимитом одновременных запросов
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler._currentThreadIsProcessingItems">
            <summary>Whether the current thread is processing work items.</summary>
        </member>
        <member name="F:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler._tasks">
            <summary>The list of tasks to be executed.</summary>
        </member>
        <member name="F:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler._maxDegreeOfParallelism">
            <summary>The maximum concurrency level allowed by this scheduler.</summary>
        </member>
        <member name="F:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler._delegatesQueuedOrRunning">
            <summary>Whether the scheduler is currently processing work items.</summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler.#ctor(System.Int32)">
            <summary>
            Конструктор LimitedConcurrencyLevelTaskScheduler
            </summary>
            <param name="maxDegreeOfParallelism">Максимальный уровень параллелизма</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler.#ctor">
            <summary>
            Конструктор LimitedConcurrencyLevelTaskScheduler
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Заносит Task в планировщик</summary>
            <param name="task">Новый Task</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler.NotifyThreadPoolOfPendingWork">
            <summary>
            Запускаем Task из очереди
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Попробовать запустить Task в текущем потоке</summary>
            <param name="task">Task для исполнения</param>
            <param name="taskWasPreviouslyQueued">Task был в очереди</param>
            <returns>Может ли он быть запущен в текущем потоке</returns>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
            <summary>Удаление Task из очереди</summary>
            <param name="task">Task для удаления</param>
            <returns>Был ли удалён</returns>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler.GetScheduledTasks">
            <summary>Перечисление всех Task'ов в очереди</summary>
            <returns>Перечисление</returns>
        </member>
        <member name="P:Core.ServiceClasses.AsyncAwaitSupport.LimitedConcurrencyLevelTaskScheduler.MaximumConcurrencyLevel">
            <summary>Максимальная степень параллелизма</summary>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchDelegate">
            <summary>
            Делегат смены контекста исполнения
            </summary>
            <param name="act">Действие, которое будет исполнено в новом контексте</param>
            <param name="flowEContext">Протаскивать ли параметры текущего контекста</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateContextSwitchSupplier">
            <summary>
            Поставщик смены контекста по делегату, принимающему Action и flowContext
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateContextSwitchSupplier.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateContextSwitchSupplier.#ctor(Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchDelegate)">
            <summary>
            Конструктор SingleDelegateContextSwitchSupplier
            </summary>
            <param name="switchDel">Делегат смены контекста</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateContextSwitchSupplier.Run(System.Action,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateContextSwitchSupplier.RunWithState(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="state">Состояние</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchWithStateDelegate">
            <summary>
            Делегат смены контекста исполнения
            </summary>
            <param name="act">Действие, которое будет исполнено в новом контексте</param>
            <param name="state">Состояние</param>
            <param name="flowEContext">Протаскивать ли параметры текущего контекста</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateContextSwitchSupplier">
            <summary>
            Поставщик смены контекста по делегату, принимающему Action, State и flowContext
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateContextSwitchSupplier.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateContextSwitchSupplier.#ctor(Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchWithStateDelegate)">
            <summary>
            Конструктор SingleDelegateWithStateContextSwitchSupplier
            </summary>
            <param name="switchDel">Делегат смены контекста</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateContextSwitchSupplier.RunAction(System.Object)">
            <summary>
            Выполнение действия переданного как состояние
            </summary>
            <param name="act">Действие</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateContextSwitchSupplier.Run(System.Action,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateContextSwitchSupplier.RunWithState(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="state">Состояние</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchNoFlowDelegate">
            <summary>
            Делегат смены контекста исполнения
            </summary>
            <param name="act">Действие, которое будет исполнено в новом контексте</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateNoFlowContextSwitchSupplier">
            <summary>
            Поставщик смены контекста по делегату, принимающему Action
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateNoFlowContextSwitchSupplier.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateNoFlowContextSwitchSupplier.#ctor(Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchNoFlowDelegate)">
            <summary>
            Конструктор SingleDelegateNoFlowContextSwitchSupplier
            </summary>
            <param name="switchDel">Делегат смены контекста</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateNoFlowContextSwitchSupplier.Run(System.Action,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateNoFlowContextSwitchSupplier.RunWithState(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="state">Состояние</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchWithStateNoFlowDelegate">
            <summary>
            Делегат смены контекста исполнения
            </summary>
            <param name="act">Действие, которое будет исполнено в новом контексте</param>
            <param name="state">Состояние</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateNoFlowContextSwitchSupplier">
            <summary>
            Поставщик смены контекста по делегату, принимающему Action, State и flowContext
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateNoFlowContextSwitchSupplier.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateNoFlowContextSwitchSupplier.#ctor(Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchWithStateNoFlowDelegate)">
            <summary>
            Конструктор SingleDelegateWithStateNoFlowContextSwitchSupplier
            </summary>
            <param name="switchDel">Делегат смены контекста</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateNoFlowContextSwitchSupplier.RunAction(System.Object)">
            <summary>
            Выполнение действия переданного как состояние
            </summary>
            <param name="act">Действие</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateNoFlowContextSwitchSupplier.Run(System.Action,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.SingleDelegateWithStateNoFlowContextSwitchSupplier.RunWithState(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="state">Состояние</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="T:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchFromSynchroContextSupplier">
            <summary>
            Поставщик смены контекста по контексту синхронизации
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchFromSynchroContextSupplier.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchFromSynchroContextSupplier.#ctor(System.Threading.SynchronizationContext)">
            <summary>
            Конструктор ContextSwitchFromSynchroContextSupplier
            </summary>
            <param name="syncContext">Контекст синхронизации</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchFromSynchroContextSupplier.RunAction(System.Object)">
            <summary>
            Выполнение действия переданного как состояние
            </summary>
            <param name="act">Действие</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchFromSynchroContextSupplier.Run(System.Action,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.AsyncAwaitSupport.ContextSwitchFromSynchroContextSupplier.RunWithState(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="state">Состояние</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="T:System.Diagnostics.Contracts.MethodTimeTest">
            <summary>
            Класс для теста времени выполнения метода
            </summary>
        </member>
        <member name="M:System.Diagnostics.Contracts.MethodTimeTest.Start(System.Diagnostics.Contracts.MethodTimeTest@)">
            <summary>
            Запуск таймера. Вызывается из Assert, либо Requires
            </summary>
            <param name="tmr">Объект таймера</param>
            <returns>Всегда true</returns>
        </member>
        <member name="M:System.Diagnostics.Contracts.MethodTimeTest.Start(System.Diagnostics.Contracts.MethodTimeTest@,System.Int32)">
            <summary>
            Запуск таймера. Вызывается из Assert, либо Requires
            </summary>
            <param name="tmr">Объект таймера</param>
            <param name="timeout">Таймаут для предотвращения зависания метода</param>
            <returns>Всегда true</returns>
        </member>
        <member name="M:System.Diagnostics.Contracts.MethodTimeTest.TestCurrent(System.Diagnostics.Contracts.MethodTimeTest,System.Int32)">
            <summary>
            Проверить текущее время. Вызывается из Assert, либо Ensures
            </summary>
            <param name="tmr">Объект таймера</param>
            <param name="time">Время для сравнения в миллисекундах</param>
            <returns>Меньше ли времени прошло</returns>
        </member>
        <member name="M:System.Diagnostics.Contracts.MethodTimeTest.StopAndTest(System.Diagnostics.Contracts.MethodTimeTest,System.Int32)">
            <summary>
            Остановить таймер и проверить текущее время. Вызывается из Assert, либо Ensures
            </summary>
            <param name="tmr">Объект таймера</param>
            <param name="time">Время для сравнения в миллисекундах</param>
            <returns>Меньше ли времени прошло</returns>
        </member>
        <member name="M:System.Diagnostics.Contracts.MethodTimeTest.#ctor">
            <summary>
            Конструктор
            </summary>
        </member>
        <member name="M:System.Diagnostics.Contracts.MethodTimeTest.#ctor(System.Int32)">
            <summary>
            Конструктор с глобальным таймаутом от зависания
            </summary>
            <param name="timeout">Таймаут</param>
        </member>
        <member name="M:System.Diagnostics.Contracts.MethodTimeTest.TimerError(System.Object)">
            <summary>
            Функция генерации исключения по таймеру
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:System.Diagnostics.Contracts.MethodTimeTest.Stop">
            <summary>
            Остановка таймера
            </summary>
        </member>
        <member name="P:System.Diagnostics.Contracts.MethodTimeTest.StartTime">
            <summary>
            Время запуска
            </summary>
        </member>
        <member name="P:System.Diagnostics.Contracts.MethodTimeTest.StopTime">
            <summary>
            Время остановки
            </summary>
        </member>
        <member name="P:System.Diagnostics.Contracts.MethodTimeTest.Period">
            <summary>
            Прошедший с запуска период времени
            </summary>
        </member>
        <member name="T:System.Collections.Generic.ByReferenceEqualityComparer`1">
            <summary>
            Сравнение объектов по ссылке
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:System.Collections.Generic.ByReferenceEqualityComparer`1.Equals(`0,`0)">
            <summary>
            Сравнение
            </summary>
            <param name="x">X</param>
            <param name="y">Y</param>
            <returns>Равны ли ссылки</returns>
        </member>
        <member name="M:System.Collections.Generic.ByReferenceEqualityComparer`1.GetHashCode(`0)">
            <summary>
            Получение hash
            </summary>
            <param name="obj">Объект</param>
            <returns>Hash</returns>
        </member>
        <member name="P:System.Collections.Generic.ByReferenceEqualityComparer`1.Default">
            <summary>
            Стандартный сравниватель
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Collections.Deque`1">
            <summary>
            Дек. Позволяет добавлять и извлекать элементы из начала и конца.
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
        </member>
        <member name="F:Core.ServiceClasses.Collections.Deque`1.MinimumGrow">
            <summary>
            Минимальный размер, на который увеличивается внутренний массив
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.Collections.Deque`1.ShrinkRate">
            <summary>
            Порог обрезания размера внутреннего массива (Count &lt; ShrinkRate * Capacity)
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.Collections.Deque`1.GrowFactor">
            <summary>
            Степень расширения массива при нехватке элементов
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.Collections.Deque`1.DefaultCapacity">
            <summary>
            Вместимость по умолчанию
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.#ctor">
            <summary>
            Конструктор Deque
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.#ctor(System.Int32)">
            <summary>
            Конструктор Deque с преаллокацией
            </summary>
            <param name="capacity">Начальная вместимость</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Конструктор Deque
            </summary>
            <param name="collection">Исходная коллекция</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.GetElement(System.Int32)">
            <summary>
            Получить элемент с определённым индексом
            </summary>
            <param name="i">Индекс</param>
            <returns>Элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.Clear">
            <summary>
            Очистить дек
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.CopyTo(`0[],System.Int32)">
            <summary>
            Скопировать содержимое в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Начальный индекс</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.AddToBack(`0)">
            <summary>
            Добавить элемент в конец
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.AddToFront(`0)">
            <summary>
            Добавить элемент в начало
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.PeekAtFront">
            <summary>
            Просмотреть элемент в начале
            </summary>
            <returns>Элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.PeekAtEnd">
            <summary>
            Просмотреть элемент в конце
            </summary>
            <returns>Элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.RemoveFromFront">
            <summary>
            Удалить из начала
            </summary>
            <returns>Элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.RemoveFromBack">
            <summary>
            Удалить из конца
            </summary>
            <returns>Элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.Contains(`0)">
            <summary>
            Содержится ли элемент в деке
            </summary>
            <param name="item">Элемент</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.ToArray">
            <summary>
            Скопировать в массив
            </summary>
            <returns>Массив</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.TrimExcess">
            <summary>
            Обрезать размеры внутреннего массива
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.SetCapacity(System.Int32,System.Int32)">
            <summary>
            Задать размер внутреннего массива
            </summary>
            <param name="headOffset">Смещение данных от начала</param>
            <param name="capacity">Желаемая вместимость</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.GetEnumerator">
            <summary>
            Получить Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Получить Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Получить Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Скопировать данные в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Начальный индекс</param>
        </member>
        <member name="P:Core.ServiceClasses.Collections.Deque`1.Count">
            <summary>
            Количество элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.Deque`1.Capacity">
            <summary>
            Внутренняя вместимость
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.Deque`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Синхронизирована ли коллекция
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.Deque`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Объект инхронизации
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Collections.Deque`1.Enumerator">
            <summary>
            Enumerator для дека
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.Enumerator.#ctor(Core.ServiceClasses.Collections.Deque{`0})">
            <summary>
            Конструктор Enumerator
            </summary>
            <param name="srcDeque">Дек, по которому проходимся</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.Enumerator.MoveNext">
            <summary>
            Перейти к следующему элементу
            </summary>
            <returns></returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.Enumerator.Dispose">
            <summary>
            Удалить ресурсы
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.Deque`1.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Сбросить перечисление
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.Deque`1.Enumerator.Current">
            <summary>
            Текущий элемент
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.Deque`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Текущий элемент
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Collections.OutOfTurnQueue`1">
            <summary>
            Очередь с возможностью добавления элементов в начало
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.#ctor">
            <summary>
            Конструктор OutOfTurnQueue
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.#ctor(System.Int32)">
            <summary>
            Конструктор OutOfTurnQueue
            </summary>
            <param name="capacity">Начальная вместимость</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Конструктор OutOfTurnQueue
            </summary>
            <param name="collection">Начальные элементы</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.Clear">
            <summary>
            Очистить очередь
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Скопировать элементы в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Начальный индекс</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.Enqueue(`0)">
            <summary>
            Добавить элемент в конец очереди
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.EnqueueToFront(`0)">
            <summary>
            Добавить элемент в начало очереди
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.Peek">
            <summary>
            Просмотреть элемент в голове очереди
            </summary>
            <returns>Элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.Dequeue">
            <summary>
            Вытащить элемент из головы очереди
            </summary>
            <returns></returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.Contains(`0)">
            <summary>
            Содержит ли очередь элементы
            </summary>
            <param name="item">Элемент</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.ToArray">
            <summary>
            Скопировать элементы в массив
            </summary>
            <returns>Массив</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.TrimExcess">
            <summary>
            Удалить лишнее пустое место
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.GetEnumerator">
            <summary>
            Получить Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Получить Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Получить Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.OutOfTurnQueue`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Скопировать данные в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Начальный индекс</param>
        </member>
        <member name="P:Core.ServiceClasses.Collections.OutOfTurnQueue`1.Count">
            <summary>
            Количество элементов в очереди
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.OutOfTurnQueue`1.Capacity">
            <summary>
            Вместимость очереди
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.OutOfTurnQueue`1.System#Collections#ICollection#Count">
            <summary>
            Количество элементов в очереди
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.OutOfTurnQueue`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Синхронизирована ли коллекция
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.OutOfTurnQueue`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Объект инхронизации
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.OutOfTurnQueue`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <summary>
            Количество элементов в очереди
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Collections.HighLowPriority">
            <summary>
            Два уровня приоритета
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.Collections.HighLowPriority.High">
            <summary>
            Высокий приоритет
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.Collections.HighLowPriority.Low">
            <summary>
            Обычный приоритет (низкий)
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Collections.HighLowPriorityQueue`1">
            <summary>
            Очередь с 2-мя уровнями приоритета
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2">
            <summary>
            Очередь с фиксированным числом приоритетов
            </summary>
            <typeparam name="TElem">Тип элемента</typeparam>
            <typeparam name="TPriority">Тип приоритета</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.#ctor(System.Int32)">
            <summary>
            Конструктор LimitedPriorityQueueBase
            </summary>
            <param name="priorityLevelsCount">Количество уровней приоритета</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Конструктор LimitedPriorityQueueBase
            </summary>
            <param name="collection">Исходные данные (попадут в коллекцию с минимальным приоритетом)</param>
            <param name="priorityLevelsCount">Количество уровней приоритета</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.MapPriority(`1)">
            <summary>
            Отображение типа приоритета на его номер
            </summary>
            <param name="prior">Приоритет</param>
            <returns>Номер приоритета</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.Clear">
            <summary>
            Очистить очередь
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.CopyTo(`0[],System.Int32)">
            <summary>
            Скопировать элементы в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Начальный индекс</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.Enqueue(`0,`1)">
            <summary>
            Добавить элемент в очередь с указанным приоритетом
            </summary>
            <param name="item">Элемент</param>
            <param name="priority">Приоритет</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.Peek">
            <summary>
            Просмотреть элемент с головы очереди
            </summary>
            <returns>Элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.Dequeue">
            <summary>
            Выбрать элемент с головы очереди
            </summary>
            <returns>Элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.Contains(`0)">
            <summary>
            Содержит ли очередь элемент
            </summary>
            <param name="item">Элемент</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.ToArray">
            <summary>
            Скопировать элементы в массив
            </summary>
            <returns>Массив</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.TrimExcess">
            <summary>
            Удалить излишнее пустое место
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.GetEnumerator">
            <summary>
            Получить Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Получить Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Скопировать данные в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Начальный индекс</param>
        </member>
        <member name="P:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.PriorityLevelsCount">
            <summary>
            Количество уровней приоритета
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.Count">
            <summary>
            Количество элементов в очереди
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Синхронизирована ли коллекция
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Collections.LimitedPriorityQueueBase`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Объект инхронизации
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.HighLowPriorityQueue`1.#ctor">
            <summary>
            Конструктор HighLowPriorityQueue
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Collections.HighLowPriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Конструктор HighLowPriorityQueue
            </summary>
            <param name="collection">Начальная коллекция</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.HighLowPriorityQueue`1.MapPriority(Core.ServiceClasses.Collections.HighLowPriority)">
            <summary>
            Отображение типа приоритета на его номер
            </summary>
            <param name="prior">Приоритет</param>
            <returns>Номер приоритета</returns>
        </member>
        <member name="M:Core.ServiceClasses.Collections.HighLowPriorityQueue`1.Enqueue(`0)">
            <summary>
            Добавить элемен в конец очереди с низким приоритетом
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Collections.HighLowPriorityQueue`1.EnqueueHigh(`0)">
            <summary>
            Добавить элемен в конец очереди с высоким приоритетом
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="T:Core.ServiceClasses.Collections.LimitedPriorityQueueBaseCodeContract`2">
            <summary>
            Контракты
            </summary>
            <typeparam name="TElem">Тип элемента</typeparam>
            <typeparam name="TPriority">Тип приоритета</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.Collections.ServiceStuff.CollectionDebugView`1">
            <summary>
            Представление коллекции для отображения в отладчике
            </summary>
            <typeparam name="T">Тип элементов коллекции</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Collections.ServiceStuff.CollectionDebugView`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Конструктор CollectionDebugView
            </summary>
            <param name="collection">Коллекция</param>
        </member>
        <member name="P:Core.ServiceClasses.Collections.ServiceStuff.CollectionDebugView`1.Items">
            <summary>
            Элементы коллекции
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2">
            <summary>
            Словарь в режиме только для чтения
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.#ctor">
            <summary>
            Конструктор ReadOnlyDictionary
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.Dictionary{`0,`1})">
            <summary>
            Конструктор ReadOnlyDictionary
            </summary>
            <param name="dict">Обёртываемый словарь</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Конструктор ReadOnlyDictionary
            </summary>
            <param name="srcDict">Источник элементов словаря</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Конструктор ReadOnlyDictionary
            </summary>
            <param name="srcDict">Источник элементов словаря</param>
            <param name="keyComparer">Компаратор ключей</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Получить значение по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="value">Полученное значение</param>
            <returns>Удалось ли получить значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>
            Содержится ли ключ в словаре
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.ContainsValue(`1)">
            <summary>
            Содержится ли значение в словаре
            </summary>
            <param name="value">Значение</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Add(`0,`1)">
            <summary>
            Добавить в словарь (не поддерживается)
            </summary>
            <param name="key">Ключ</param>
            <param name="value">Значение</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#ContainsKey(`0)">
            <summary>
            Содержится ли ключ в словаре
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Remove(`0)">
            <summary>
            Удалить из словаря (не поддерживается)
            </summary>
            <param name="key">Ключ</param>
            <returns>Удалился ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#TryGetValue(`0,`1@)">
            <summary>
            Получить значение по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="value">Извлечённое значение</param>
            <returns>Было ли значение в словаре</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Добавить элемент в коллекцию (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Clear">
            <summary>
            Оичтить словарь (не поддерживается)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Содержится ли элемент в словаре
            </summary>
            <param name="item">Элемент</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Скопировать данные словаря в массив
            </summary>
            <param name="array">Массив</param>
            <param name="arrayIndex">Индекс, с которого начинается вставка</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Удалить элемент (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
            <returns>Удалился ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey@TValue}}#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>
            Добавить в словарь (не поддерживается)
            </summary>
            <param name="key">Ключ</param>
            <param name="value">Значение</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#Clear">
            <summary>
            Очистить словарь (не поддерживается)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>
            Содержит ли словарь ключ
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>
            Удалить элемент из словаря по ключу (не поддерживается)
            </summary>
            <param name="key">Ключ</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Скопировать содержимое в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Стартовый индекс</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#ContainsKey(`0)">
            <summary>
            Содержит ли словарь ключ
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#TryGetValue(`0,`1@)">
            <summary>
            Получить значение по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="value">Извлечённое значение</param>
            <returns>Было ли значение в словаре</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.Empty">
            <summary>
            Пустой словарь
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.Dictionary">
            <summary>
            Обёрнутый словарь
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.Count">
            <summary>
            Количество элементов в словаре
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.Keys">
            <summary>
            Коллекция ключей
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.Values">
            <summary>
            Коллекция значений
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.Item(`0)">
            <summary>
            Доступ к элементам по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Элемент</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Keys">
            <summary>
            Коллекция ключей
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Values">
            <summary>
            Коллекция значений
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{TKey@TValue}#Item(`0)">
            <summary>
            Доступ к элементам словаря по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Значение</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Count">
            <summary>
            Количество элементов в словаре
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#IsReadOnly">
            <summary>
            Только для чтения
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>
            Фиксирован ли размер
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#IsReadOnly">
            <summary>
            Только для чтения
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#Keys">
            <summary>
            Коллекция ключей
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#Values">
            <summary>
            Коллекция значений
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>
            Доступ к элементам словаря по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Значение</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#ICollection#Count">
            <summary>
            Количество элементов в словаре
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Синхронизирован ли доступ
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Объект синхронизации
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#Keys">
            <summary>
            Перечень ключей
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#Values">
            <summary>
            Перечень элементов словаря
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IReadOnlyDictionary{TKey@TValue}#Item(`0)">
            <summary>
            Доступ к элементам словаря по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Значение</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionary`2.System#Collections#Generic#IReadOnlyCollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#Count">
            <summary>
            Количество элементов в словаре
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1">
            <summary>
            Обёртка множества в режиме только для чтения
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.#ctor">
            <summary>
            Конструктор ReadOnlyHashSet
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.#ctor(System.Collections.Generic.HashSet{`0})">
            <summary>
            Конструктор ReadOnlyHashSet
            </summary>
            <param name="set">Обёртываемое множество</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Конструктор ReadOnlyHashSet
            </summary>
            <param name="set">Исходные элементы</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Конструктор ReadOnlyHashSet
            </summary>
            <param name="set">Исходные элементы</param>
            <param name="eqCmp">Компаратор данных</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество строгим подмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли строгим подмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество строгим надмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли строгим надмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество подмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли подмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество надмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли надмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Пересекаются ли множества
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Пересекаются ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Эквивалентны ли множества
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Эквивалентны ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.Contains(`0)">
            <summary>
            Проверка наличия элемента в коллекции
            </summary>
            <param name="item">Элемент</param>
            <returns>Есть ли он в коллекции</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Копирование коллекции в массив начиная с заданного индекса
            </summary>
            <param name="array">Массив, в который копируем</param>
            <param name="arrayIndex">Индекс внутри массива</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.GetEnumerator">
            <summary>
            Получение Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#Add(`0)">
            <summary>
            Добавление элемента в множество (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Исключить элементы из множества (не поддерживается)
            </summary>
            <param name="other">Перечень элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Пересечь с элементами из перечня (не поддерживается)
            </summary>
            <param name="other">Перечень элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество строгим подмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли строгим подмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество строгим надмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли строгим надмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество подмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли подмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество надмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли надмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Пересекаются ли множества
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Пересекаются ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Эквивалентны ли множества
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Эквивалентны ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Симметричное исключение элементов. 
            В результате содержится либо элементы исходного множества, либо другого, но не обоих вместе.
            (не поддерживается)
            </summary>
            <param name="other">Перечень элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ISet{T}#UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Объеденить с множеством (не поддерживается)
            </summary>
            <param name="other">Множество элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Добавление элемента в множество (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>
            Оичтка множества (не поддерживается)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ICollection{T}#Contains(`0)">
            <summary>
            Содержится ли элемент в множестве
            </summary>
            <param name="item">Элемент</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <summary>
            Скопировать данные множества в массив
            </summary>
            <param name="array">Массив</param>
            <param name="arrayIndex">Индекс, с которого начинается вставка</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            Удалить элемент (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
            <returns>Удалился ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Скопировать содержимое в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Стартовый индекс</param>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.Empty">
            <summary>
            Пустое множество
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.Items">
            <summary>
            Обёртываемое множество
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.Count">
            <summary>
            Число элементов в множестве
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ICollection{T}#Count">
            <summary>
            Количество элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Только для чтения
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#ICollection#Count">
            <summary>
            Количество элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Синхронизирован ли доступ
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Объект синхронизации
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyHashSet`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <summary>
            Количество элементов
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1">
            <summary>
            Коллекция в режиме только для чтения
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Конструктор ReadOnlyCollectionWrapper
            </summary>
            <param name="collection">Обёртываемая коллекция</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.Contains(`0)">
            <summary>
            Проверка наличия элемента в коллекции
            </summary>
            <param name="item">Элемент</param>
            <returns>Есть ли он в коллекции</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.CopyTo(`0[],System.Int32)">
            <summary>
            Копирование коллекции в массив начиная с заданного индекса
            </summary>
            <param name="array">Массив, в который копируем</param>
            <param name="arrayIndex">Индекс внутри массива</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.GetEnumerator">
            <summary>
            Получение Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Добавление элемента в конец (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>
            Оичтка коллекции (не поддерживается)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#Generic#ICollection{T}#Contains(`0)">
            <summary>
            Содержится ли элемент в коллекции
            </summary>
            <param name="item">Элемент</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <summary>
            Скопировать данные коллекции в массив
            </summary>
            <param name="array">Массив</param>
            <param name="arrayIndex">Индекс, с которого начинается вставка</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            Удалить элемент (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
            <returns>Удалился ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Скопировать содержимое в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Стартовый индекс</param>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.Empty">
            <summary>
            Пустая коллекция
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.Items">
            <summary>
            Обёртываемая коллекция
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.Count">
            <summary>
            Число элементов в коллекции
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#Generic#ICollection{T}#Count">
            <summary>
            Количество элементов в коллекции
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Только для чтения
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#ICollection#Count">
            <summary>
            Количество элементов в коллекции
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Синхронизирован ли доступ
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Объект синхронизации
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyCollectionWrapper`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <summary>
            Количество элементов в коллекции
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionaryWrapper`2">
            <summary>
            Словарь в режиме только для чтения
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionaryWrapper`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Конструктор ReadOnlyDictionaryWrapper
            </summary>
            <param name="dict">Обёртываемый словарь</param>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyDictionaryWrapper`2.Empty">
            <summary>
            Пустой словарь
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1">
            <summary>
            Список в режиме только для чтения
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.#ctor">
            <summary>
            Конструктор ReadOnlyList без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Конструктор ReadOnlyList
            </summary>
            <param name="list">Обёртываемый список</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Конструктор ReadOnlyList из перечня данных
            </summary>
            <param name="data">Данные</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.IndexOf(`0)">
            <summary>
            Позиция первого включения элемента в список
            </summary>
            <param name="item">Элемент</param>
            <returns>Позиция, если найден, иначе -1</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.LastIndexOf(`0)">
            <summary>
            Позиция элемента в списке (поиск идёт с конца)
            </summary>
            <param name="item">Элемент</param>
            <returns>Позиция, если найден, иначе -1</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.Contains(`0)">
            <summary>
            Проверка наличия элемента в коллекции
            </summary>
            <param name="item">Элемент</param>
            <returns>Есть ли он в коллекции</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Копирование коллекции в массив начиная с заданного индекса
            </summary>
            <param name="array">Массив, в который копируем</param>
            <param name="arrayIndex">Индекс внутри массива</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.GetEnumerator">
            <summary>
            Получение Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.Exists(System.Predicate{`0})">
            <summary>
            Существует ли в списке хоть один элемент, для которого пердикат вернёт true
            </summary>
            <param name="match">Предикат</param>
            <returns>Существование элемента</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.ToArray">
            <summary>
            Конвертация в массив
            </summary>
            <returns>Массив</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.ForEach(System.Action{`0})">
            <summary>
            Выполнение действия для каждого элемента списка
            </summary>
            <param name="action">Действие</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.TrueForAll(System.Predicate{`0})">
            <summary>
            Выполняется ли предикат для всех элементов списка
            </summary>
            <param name="match">Предикат</param>
            <returns>Выполняется ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.AsTransformedReadOnlyList``1(System.Func{`0,``0})">
            <summary>
            Получить список с преобразованием элементов на лету
            </summary>
            <typeparam name="TOut">Выходной тип элементов</typeparam>
            <param name="selector">Преобразователь</param>
            <returns>Список</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#IList{T}#IndexOf(`0)">
            <summary>
            Индекс элемента в списке
            </summary>
            <param name="item">Элемент</param>
            <returns>Индекс, если присутствует, иначе -1</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <summary>
            Вставка элемента в список (не поддерживается)
            </summary>
            <param name="index">Индекс</param>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <summary>
            Удаление элемента из списка (не поддерживается)
            </summary>
            <param name="index">Индекс элемента</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Добавление элемента в конец (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>
            Оичтка списка (не поддерживается)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#Contains(`0)">
            <summary>
            Содержится ли элемент в списке
            </summary>
            <param name="item">Элемент</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <summary>
            Скопировать данные списка в массив
            </summary>
            <param name="array">Массив</param>
            <param name="arrayIndex">Индекс, с которого начинается вставка</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            Удалить элемент (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
            <returns>Удалился ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#Add(System.Object)">
            <summary>
            Добавить элемент в список (не поддерживается)
            </summary>
            <param name="value">Элемент</param>
            <returns>Позиция</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#Clear">
            <summary>
            Очистить список (не поддерживается)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#Contains(System.Object)">
            <summary>
            Сожержит ли список элемент
            </summary>
            <param name="value">Элемент</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Индекс элемента в списке
            </summary>
            <param name="value">Элемент</param>
            <returns>Индекс, если есть, иначе -1</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Вставка элемента в список (не поддерживается)
            </summary>
            <param name="index">Индекс</param>
            <param name="value">Значение</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#Remove(System.Object)">
            <summary>
            Удалить элемент из списка (не поддерживается)
            </summary>
            <param name="value">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
            Удалить элемент из списка в определённой позиции (не поддерживается)
            </summary>
            <param name="index">Индекс</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Скопировать содержимое в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Стартовый индекс</param>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.Empty">
            <summary>
            Пустой список
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.Items">
            <summary>
            Обёртываемый список
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.Item(System.Int32)">
            <summary>
            Получение элемента списка по индексу
            </summary>
            <param name="index">Индекс</param>
            <returns>Элемент</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.Count">
            <summary>
            Число элементов в списке
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <summary>
            Доступ к элементам по индексу
            </summary>
            <param name="index">Индекс</param>
            <returns>Элемент</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#Count">
            <summary>
            Количество элементов в списке
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Только для чтения
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#IReadOnlyList{T}#Item(System.Int32)">
            <summary>
            Доступ к элементам списка по индексу
            </summary>
            <param name="index">Индекс</param>
            <returns>Элемент</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <summary>
            Количество элементов в списке
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#IsFixedSize">
            <summary>
            Фиксирован ли размер
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#IsReadOnly">
            <summary>
            Только для чтения
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#IList#Item(System.Int32)">
            <summary>
            Доступ к элементам списка по индексу
            </summary>
            <param name="index">Индекс</param>
            <returns>Элемент</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#ICollection#Count">
            <summary>
            Количество элементов в списке
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Синхронизирован ли доступ
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyList`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Объект синхронизации
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.CollectionWrappers.ReadOnlyListWrapper`1">
            <summary>
            Обёртка списков в режим только для чтения
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyListWrapper`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Конструктор ReadOnlyListWrapper
            </summary>
            <param name="list">Обёртываемый список</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyListWrapper`1.LastIndexOf(`0)">
            <summary>
            Позиция последнего элемента в списке
            </summary>
            <param name="item">Элемент</param>
            <returns>Позиция, если найден, иначе -1</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyListWrapper`1.ForEach(System.Action{`0})">
            <summary>
            Выполнение действия для каждого элемента списка
            </summary>
            <param name="action">Действие</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlyListWrapper`1.AsTransformedReadOnlyList``1(System.Func{`0,``0})">
            <summary>
            Получить список с преобразованием элементов на лету
            </summary>
            <typeparam name="TOut">Выходной тип элементов</typeparam>
            <param name="selector">Преобразователь</param>
            <returns>Список</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlyListWrapper`1.Empty">
            <summary>
            Пустой список
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1">
            <summary>
            Обёртка множества в режиме только для чтения
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.#ctor(System.Collections.Generic.ISet{`0})">
            <summary>
            Конструктор ReadOnlySetWrapper
            </summary>
            <param name="set">Обёртываемое множество</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество строгим подмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли строгим подмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество строгим надмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли строгим надмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество подмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли подмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество надмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли надмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Пересекаются ли множества
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Пересекаются ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Эквивалентны ли множества
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Эквивалентны ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.Contains(`0)">
            <summary>
            Проверка наличия элемента в коллекции
            </summary>
            <param name="item">Элемент</param>
            <returns>Есть ли он в коллекции</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.CopyTo(`0[],System.Int32)">
            <summary>
            Копирование коллекции в массив начиная с заданного индекса
            </summary>
            <param name="array">Массив, в который копируем</param>
            <param name="arrayIndex">Индекс внутри массива</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.GetEnumerator">
            <summary>
            Получение Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#Add(`0)">
            <summary>
            Добавление элемента в множество (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Исключить элементы из множества (не поддерживается)
            </summary>
            <param name="other">Перечень элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Пересечь с элементами из перечня (не поддерживается)
            </summary>
            <param name="other">Перечень элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество строгим подмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли строгим подмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество строгим надмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли строгим надмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество подмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли подмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Явлется ли множество надмножеством коллекции other
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Является ли надмножеством</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Пересекаются ли множества
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Пересекаются ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Эквивалентны ли множества
            </summary>
            <param name="other">Коллекция для проверки</param>
            <returns>Эквивалентны ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Симметричное исключение элементов. 
            В результате содержится либо элементы исходного множества, либо другого, но не обоих вместе.
            (не поддерживается)
            </summary>
            <param name="other">Перечень элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ISet{T}#UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Объеденить с множеством (не поддерживается)
            </summary>
            <param name="other">Множество элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Добавление элемента в множество (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ICollection{T}#Clear">
            <summary>
            Оичтка множества (не поддерживается)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ICollection{T}#Contains(`0)">
            <summary>
            Содержится ли элемент в множестве
            </summary>
            <param name="item">Элемент</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <summary>
            Скопировать данные множества в массив
            </summary>
            <param name="array">Массив</param>
            <param name="arrayIndex">Индекс, с которого начинается вставка</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <summary>
            Удалить элемент (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
            <returns>Удалился ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Скопировать содержимое в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Стартовый индекс</param>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.Empty">
            <summary>
            Пустое множество
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.Items">
            <summary>
            Обёртываемое множество
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.Count">
            <summary>
            Число элементов в множестве
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ICollection{T}#Count">
            <summary>
            Количество элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Только для чтения
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#ICollection#Count">
            <summary>
            Количество элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Синхронизирован ли доступ
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Объект синхронизации
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.ReadOnlySetWrapper`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <summary>
            Количество элементов
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2">
            <summary>
            Список с преобразованием элементов на лету
            </summary>
            <typeparam name="TIn"></typeparam>
            <typeparam name="TOut"></typeparam>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.IsCompatibleObject``1(System.Object)">
            <summary>
            Конвертируем ли объект в определённый тип
            </summary>
            <typeparam name="T">Тип, в который надо конвертировать</typeparam>
            <param name="value">Объект</param>
            <returns>Можно ли конвертировать</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.#ctor(System.Collections.Generic.IList{`0},System.Func{`0,`1})">
            <summary>
            Конструктор TransformedReadOnlyListWrapper
            </summary>
            <param name="list">Исходный список</param>
            <param name="transformator">Функция конвертации</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.GetEnumerator">
            <summary>
            Получение Enumerator
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.CopyTo(`1[],System.Int32)">
            <summary>
            Копирование коллекции в массив начиная с заданного индекса
            </summary>
            <param name="array">Массив, в который копируем</param>
            <param name="arrayIndex">Индекс внутри массива</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.ForEach(System.Action{`1})">
            <summary>
            Выполнение действия для каждого элемента списка
            </summary>
            <param name="action">Действие</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.IndexOf(`1)">
            <summary>
            Позиция первого элемента в списке
            </summary>
            <param name="item">Элемент</param>
            <returns>Позиция, если найден, иначе -1</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.LastIndexOf(`1)">
            <summary>
            Позиция элемента в списке (поиск идёт с конца)
            </summary>
            <param name="item">Элемент</param>
            <returns>Позиция, если найден, иначе -1</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.Contains(`1)">
            <summary>
            Проверка наличия элемента в коллекции
            </summary>
            <param name="item">Элемент</param>
            <returns>Есть ли он в коллекции</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#IList{TOut}#IndexOf(`1)">
            <summary>
            Индекс элемента в списке
            </summary>
            <param name="item">Элемент</param>
            <returns>Индекс, если присутствует, иначе -1</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#IList{TOut}#Insert(System.Int32,`1)">
            <summary>
            Вставка элемента в список (не поддерживается)
            </summary>
            <param name="index">Индекс</param>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#IList{TOut}#RemoveAt(System.Int32)">
            <summary>
            Удаление элемента из списка (не поддерживается)
            </summary>
            <param name="index">Индекс элемента</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#ICollection{TOut}#Add(`1)">
            <summary>
            Добавление элемента в конец (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#ICollection{TOut}#Clear">
            <summary>
            Оичтка списка (не поддерживается)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#ICollection{TOut}#Contains(`1)">
            <summary>
            Содержится ли элемент в списке
            </summary>
            <param name="item">Элемент</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#ICollection{TOut}#CopyTo(`1[],System.Int32)">
            <summary>
            Скопировать данные списка в массив
            </summary>
            <param name="array">Массив</param>
            <param name="arrayIndex">Индекс, с которого начинается вставка</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#ICollection{TOut}#Remove(`1)">
            <summary>
            Удалить элемент (не поддерживается)
            </summary>
            <param name="item">Элемент</param>
            <returns>Удалился ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#IEnumerable{TOut}#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Получение Enumerator'а
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#Add(System.Object)">
            <summary>
            Добавить элемент в список (не поддерживается)
            </summary>
            <param name="value">Элемент</param>
            <returns>Позиция</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#Clear">
            <summary>
            Очистить список (не поддерживается)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#Contains(System.Object)">
            <summary>
            Сожержит ли список элемент
            </summary>
            <param name="value">Элемент</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#IndexOf(System.Object)">
            <summary>
            Индекс элемента в списке
            </summary>
            <param name="value">Элемент</param>
            <returns>Индекс, если есть, иначе -1</returns>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
            Вставка элемента в список (не поддерживается)
            </summary>
            <param name="index">Индекс</param>
            <param name="value">Значение</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#Remove(System.Object)">
            <summary>
            Удалить элемент из списка (не поддерживается)
            </summary>
            <param name="value">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
            Удалить элемент из списка в определённой позиции (не поддерживается)
            </summary>
            <param name="index">Индекс</param>
        </member>
        <member name="M:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Скопировать содержимое в массив
            </summary>
            <param name="array">Массив</param>
            <param name="index">Стартовый индекс</param>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.Items">
            <summary>
            Обёртываемый список
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.Transformer">
            <summary>
            Функция преобразования
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.Item(System.Int32)">
            <summary>
            Получение элемента списка по индексу
            </summary>
            <param name="index">Индекс</param>
            <returns>Элемент</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.Count">
            <summary>
            Число элементов в списке
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#IList{TOut}#Item(System.Int32)">
            <summary>
            Доступ к элементам по индексу
            </summary>
            <param name="index">Индекс</param>
            <returns>Элемент</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#ICollection{TOut}#Count">
            <summary>
            Количество элементов в списке
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#ICollection{TOut}#IsReadOnly">
            <summary>
            Только для чтения
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#IReadOnlyList{TOut}#Item(System.Int32)">
            <summary>
            Доступ к элементам списка по индексу
            </summary>
            <param name="index">Индекс</param>
            <returns>Элемент</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#Generic#IReadOnlyCollection{TOut}#Count">
            <summary>
            Количество элементов в списке
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#IsFixedSize">
            <summary>
            Фиксирован ли размер
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#IsReadOnly">
            <summary>
            Только для чтения
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#IList#Item(System.Int32)">
            <summary>
            Доступ к элементам списка по индексу
            </summary>
            <param name="index">Индекс</param>
            <returns>Элемент</returns>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#ICollection#Count">
            <summary>
            Количество элементов в списке
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Синхронизирован ли доступ
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.CollectionWrappers.TransformedReadOnlyListWrapper`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Объект синхронизации
            </summary>
        </member>
        <member name="T:System.Collections.Generic.CollectionExtensions">
            <summary>
            Расширения для стандартных коллекций
            </summary>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.Contains``2(System.Collections.Generic.Dictionary{``0,``1}.KeyCollection,``0)">
            <summary>
            Содержится ли ключ в коллекции ключей словаря
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <param name="dictKeyCol">Коллекция ключей</param>
            <param name="item">Проверяемое значение</param>
            <returns>Содержится ли</returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AsReadOnlyList``1(System.Collections.Generic.List{``0})">
            <summary>
            Обернуть список в список ReadOnlyList только для чтения
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="list">Список</param>
            <returns>Обёрнутый список только для чтения</returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AsReadOnlyListWrapper``1(System.Collections.Generic.IList{``0})">
            <summary>
            Обернуть список в список ReadOnlyListWrapper только для чтения
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="list">Список</param>
            <returns>Обёрнутый список только для чтения</returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AsReadOnlyCollectionWrapper``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Обернуть коллекцию в ReadOnlyCollectionWrapper только для чтения
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="col">Коллекция</param>
            <returns>Обёрнутая коллекция только для чтения</returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AsReadOnlySetWrapper``1(System.Collections.Generic.ISet{``0})">
            <summary>
            Обернуть множество в ReadOnlySetWrapper
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="set">Множество</param>
            <returns>Обёрнутое множество только для чтения</returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AsReadOnlyHashSet``1(System.Collections.Generic.HashSet{``0})">
            <summary>
            Обернуть множество в ReadOnlyHashSet
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="set">Множество</param>
            <returns>Обёрнутое множество только для чтения</returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AsReadOnlyDictionaryWrapper``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Обернуть словарь в ReadOnlyDictionaryWrapper
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <param name="dict">Словарь</param>
            <returns>Обёрнутый словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AsReadOnlyDictionary``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Обернуть словарь в ReadOnlyDictionary
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <param name="dict">Словарь</param>
            <returns>Обёрнутый словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionExtensions.AsTransformedReadOnlyList``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
            Получить список с преобразованием элементов на лету
            </summary>
            <typeparam name="TIn">Исходный тип элементов</typeparam>
            <typeparam name="TOut">Выходной тип элементов</typeparam>
            <param name="list">Исходный список</param>
            <param name="selector">Преобразователь</param>
            <returns>Список</returns>
        </member>
        <member name="T:System.ExceptionExtensions">
            <summary>
            Расширение для исключений
            </summary>
        </member>
        <member name="M:System.ExceptionExtensions.GetFullDescription(System.Exception)">
            <summary>
            Получение подробного описания исключения
            </summary>
            <param name="ex">Исключение</param>
            <returns>Описание</returns>
        </member>
        <member name="M:System.ExceptionExtensions.GetShortDescription(System.Exception)">
            <summary>
            Получение краткого описания исключения (без StackTrace)
            </summary>
            <param name="ex">Исключение</param>
            <returns>Описание</returns>
        </member>
        <member name="M:System.ExceptionExtensions.IsCodeContractException(System.Exception)">
            <summary>
            Является ли исключение - исключением из библиотеки контрактов
            </summary>
            <param name="ex">Исключение</param>
            <returns>Является ли</returns>
        </member>
        <member name="T:Core.ServiceClasses.IConsumer`1">
            <summary>
            Потребитель элементов
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IConsumer`1.Add(`0)">
            <summary>
            Добавить элемент
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.IConsumer`1.TryAdd(`0)">
            <summary>
            Попытаться добавить элемент
            </summary>
            <param name="item">Элемент</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IFreezable">
            <summary>
            Поддержка заморозки. Замороженный объект должен стать неизменяемым.
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IFreezable.Freeze">
            <summary>
            Заморозить
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IFreezable.IsFrozen">
            <summary>
            Заморожен ли объект
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IProducer`1">
            <summary>
            Поставщик элементов
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IProducer`1.Take">
            <summary>
            Взять элемент
            </summary>
            <returns>Выбранный элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.IProducer`1.TryTake(`0@)">
            <summary>
            Попытаться взять элемент
            </summary>
            <param name="item">Выбранный элемент</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IProducerConsumer`1">
            <summary>
            Поставщик/потребитель элементов
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="T:System.Linq.EnumerableExtensions">
            <summary>
            Дополнительные функции LINQ to Object
            </summary>
        </member>
        <member name="M:System.Linq.EnumerableExtensions.FindPosition``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Поиск позиции элемента в коллекции
            </summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="collection">Коллекция</param>
            <param name="predicate">Предикат сравнения</param>
            <returns>Индекс первого подошедшего элемента. -1, если не найден</returns>
        </member>
        <member name="T:Core.ServiceClasses.CantInitThreadException">
            <summary>
            Исключение создания потока в пуле
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CantInitThreadException.#ctor">
            <summary>
            Конструктор CantInitThreadException без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CantInitThreadException.#ctor(System.String)">
            <summary>
            Конструктор CantInitThreadException с сообщением об ошибке
            </summary>
            <param name="message">Сообщение об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.CantInitThreadException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор CantInitThreadException с сообщением об ошибке и внутренним исключением
            </summary>
            <param name="message">Сообщение об ошибке</param>
            <param name="innerExc">Внутреннее исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.CantRetrieveElementException">
            <summary>
            Исключение получения элемента (из пула)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CantRetrieveElementException.#ctor">
            <summary>
            Конструктор CantRetrieveElementException без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CantRetrieveElementException.#ctor(System.String)">
            <summary>
            Конструктор CantRetrieveElementException с сообщением об ошибке
            </summary>
            <param name="message">Сообщение об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.CantRetrieveElementException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор CantRetrieveElementException с сообщением об ошибке и внутренним исключением
            </summary>
            <param name="message">Сообщение об ошибке</param>
            <param name="innerExc">Внутреннее исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.ItemAlreadyExistsException">
            <summary>
            Исключение, когда элемент уже присутсвует
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ItemAlreadyExistsException.#ctor">
            <summary>
            Конструктор ItemAlreadyExistsException
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ItemAlreadyExistsException.#ctor(System.String)">
            <summary>
            Конструктор ItemAlreadyExistsException
            </summary>
            <param name="message">Сообщение</param>
        </member>
        <member name="M:Core.ServiceClasses.ItemAlreadyExistsException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор ItemAlreadyExistsException
            </summary>
            <param name="message">Сообщение</param>
            <param name="innerException">Внутреннее исключение</param>
        </member>
        <member name="M:Core.ServiceClasses.ItemAlreadyExistsException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
             Конструктор ItemAlreadyExistsException для деериализации
            </summary>
            <param name="info">info</param>
            <param name="context">context</param>
        </member>
        <member name="T:Core.ServiceClasses.CommonIoCException">
            <summary>
            Исключение в IoC контейнере
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CommonIoCException.#ctor">
            <summary>
            Конструктор CommonIoCException без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.CommonIoCException.#ctor(System.String)">
            <summary>
            Конструктор CommonIoCException с сообщением об ошибке
            </summary>
            <param name="message">Сообщение об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.CommonIoCException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор CommonIoCException с сообщением об ошибке и внутренним исключением
            </summary>
            <param name="message">Сообщение об ошибке</param>
            <param name="innerExc">Внутреннее исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.AssociationIoCException">
            <summary>
            Исключение в IoC контейнере при работе с ассоциациями
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AssociationIoCException.#ctor">
            <summary>
            Конструктор AssociationIoCException без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AssociationIoCException.#ctor(System.String)">
            <summary>
            Конструктор AssociationIoCException с сообщением об ошибке
            </summary>
            <param name="message">Сообщение об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.AssociationIoCException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор AssociationIoCException с сообщением об ошибке и внутренним исключением
            </summary>
            <param name="message">Сообщение об ошибке</param>
            <param name="innerExc">Внутреннее исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.AssociationBadKeyForTypeException">
            <summary>
            Исключение в IoC контейнере при работе с ассоциациями
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AssociationBadKeyForTypeException.#ctor">
            <summary>
            Конструктор AssociationBadKeyForTypeException без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.AssociationBadKeyForTypeException.#ctor(System.String)">
            <summary>
            Конструктор AssociationBadKeyForTypeException с сообщением об ошибке
            </summary>
            <param name="message">Сообщение об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.AssociationBadKeyForTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор AssociationBadKeyForTypeException с сообщением об ошибке и внутренним исключением
            </summary>
            <param name="message">Сообщение об ошибке</param>
            <param name="innerExc">Внутреннее исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.InjectionIoCException">
            <summary>
            Исключение в IoC контейнере при работе с инъекциями
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.InjectionIoCException.#ctor">
            <summary>
            Конструктор InjectionIoCException без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.InjectionIoCException.#ctor(System.String)">
            <summary>
            Конструктор InjectionIoCException с сообщением об ошибке
            </summary>
            <param name="message">Сообщение об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.InjectionIoCException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор InjectionIoCException с сообщением об ошибке и внутренним исключением
            </summary>
            <param name="message">Сообщение об ошибке</param>
            <param name="innerExc">Внутреннее исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.ItemNotFoundException">
            <summary>
            Исключение, когда не найден элемент
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ItemNotFoundException.#ctor">
            <summary>
            Конструктор ItemNotFoundException
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ItemNotFoundException.#ctor(System.String)">
            <summary>
            Конструктор ItemNotFoundException
            </summary>
            <param name="message">Сообщение</param>
        </member>
        <member name="M:Core.ServiceClasses.ItemNotFoundException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор ItemNotFoundException
            </summary>
            <param name="message">Сообщение</param>
            <param name="innerException">Внутреннее исключение</param>
        </member>
        <member name="M:Core.ServiceClasses.ItemNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
             Конструктор ItemNotFoundException для деериализации
            </summary>
            <param name="info">info</param>
            <param name="context">context</param>
        </member>
        <member name="T:Core.ServiceClasses.ObjectFrozenException">
            <summary>
            Исключение при изменении замороженного объекта
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ObjectFrozenException.#ctor">
            <summary>
            Конструктор ObjectFrozenException без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ObjectFrozenException.#ctor(System.String)">
            <summary>
            Конструктор ObjectFrozenException с сообщением об ошибке
            </summary>
            <param name="message">Сообщение об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.ObjectFrozenException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор ObjectFrozenException с сообщением об ошибке и внутренним исключением
            </summary>
            <param name="message">Сообщение об ошибке</param>
            <param name="innerExc">Внутреннее исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.QueueAsyncProcessorException">
            <summary>
            Исключение при обработке элемента в QueueAsyncProcessor
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueAsyncProcessorException.#ctor">
            <summary>
            Конструктор QueueAsyncProcessorException без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueAsyncProcessorException.#ctor(System.String)">
            <summary>
            Конструктор QueueAsyncProcessorException с сообщением об ошибке
            </summary>
            <param name="message">Сообщение об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueAsyncProcessorException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор QueueAsyncProcessorException с сообщением об ошибке и внутренним исключением
            </summary>
            <param name="message">Сообщение об ошибке</param>
            <param name="innerExc">Внутреннее исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.WrongStateException">
            <summary>
            Исключение для ситуаций, когда объект находится в состоянии, недопустимом для данной операции
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.WrongStateException.#ctor">
            <summary>
            Конструктор WrongStateException без параметров
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.WrongStateException.#ctor(System.String)">
            <summary>
            Конструктор WrongStateException с сообщением об ошибке
            </summary>
            <param name="message">Сообщение об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.WrongStateException.#ctor(System.String,System.Exception)">
            <summary>
            Конструктор WrongStateException с сообщением об ошибке и внутренним исключением
            </summary>
            <param name="message">Сообщение об ошибке</param>
            <param name="innerExc">Внутреннее исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.ExecutionContextHlp.ExecutionContextStorage">
            <summary>
            Работа с хранилищем данных в контексте исполнения
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ExecutionContextHlp.ExecutionContextStorage.SetData(System.String,System.Object)">
            <summary>
            Установить данные
            </summary>
            <param name="name">Имя</param>
            <param name="data">Данные</param>
        </member>
        <member name="M:Core.ServiceClasses.ExecutionContextHlp.ExecutionContextStorage.GetData(System.String)">
            <summary>
            Считать данные по имени
            </summary>
            <param name="name">Имя</param>
            <returns>Данные</returns>
        </member>
        <member name="M:Core.ServiceClasses.ExecutionContextHlp.ExecutionContextStorage.SetData``1(System.String,``0)">
            <summary>
            Установить данные
            </summary>
            <typeparam name="T">Тип данных</typeparam>
            <param name="name">Имя</param>
            <param name="data">Данные</param>
        </member>
        <member name="M:Core.ServiceClasses.ExecutionContextHlp.ExecutionContextStorage.GetData``1(System.String)">
            <summary>
            Считать данные по имени
            </summary>
            <typeparam name="T">Тип данных</typeparam>
            <param name="name">Имя</param>
            <returns>Данные</returns>
        </member>
        <member name="M:Core.ServiceClasses.ExecutionContextHlp.ExecutionContextStorage.HasData(System.String)">
            <summary>
            Проверить, установленны ли данные по имени
            </summary>
            <param name="name">Имя</param>
            <returns>Да или Нет</returns>
        </member>
        <member name="M:Core.ServiceClasses.ExecutionContextHlp.ExecutionContextStorage.RemoveData(System.String)">
            <summary>
            Удалить данные по имени
            </summary>
            <param name="name">Имя</param>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1">
            <summary>
            Контейнер ассоциаций для IoC с произвольным типом ключа.
            Подходит для многопоточных сценариев
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1">
            <summary>
            Базовый контейнер ассоциаций для IoC с произвольным типом ключа
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IAssociationSource`1">
            <summary>
            Источник ассоциаций для IoC
            </summary>
            <typeparam name="TKey">Тип ключа для получения ассоциаций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IAssociationSource`1.GetAssociation(`0)">
            <summary>
            Получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <returns>Контейнер управления жизнью объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IAssociationSource`1.TryGetAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>
            Попытаться получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IAssociationSource`1.Contains(`0)">
            <summary>
            Содержит ли контейнер ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.IsGoodTypeForKey(`0,System.Type)">
            <summary>
            Подходит ли переданный тип для заданного ключа
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта</param>
            <returns>Подходит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.ProduceResolveInfo(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Сформировать Lifetime контейнер по типу и фабрике 
            </summary>
            <param name="key">Ключ, по которому будет сохранён контейнер</param>
            <param name="objType">Тип объекта, который будет обрабатывать Lifetime контейнер</param>
            <param name="val">Фабрика для создания Lifetime контейнера</param>
            <returns>Lifetime контейнер</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.AddAssociationInner(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Внутренний метод добавления ассоциации
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.TryAddAssociationInner(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Внутренний метод попытки добавить ассоциацию в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.AddAssociationInner(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Внутренний метод добавления ассоциации в контейнер с использованием фабрики формирования Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, разрешаемый по ключу</param>
            <param name="val">Фабрика созадания Lifetime контейнера</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.TryAddAssociationInner(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Внутренний метод попытки добавления ассоциации в контейнер с использованием фабрики формирования Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, разрешаемый по ключу</param>
            <param name="val">Фабрика созадания Lifetime контейнера</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.TryGetAssociationInner(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>
            Внетренний метод попытки получить ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.RemoveAssociationInner(`0)">
            <summary>
            Внутренний метод удаления ассоциации из контейнера
            </summary>
            <param name="key">Ключ</param>
            <returns>Удалили ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.ContainsInner(`0)">
            <summary>
            Внутренний метод проверки наличия ассоциации в контейнере
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.CheckContainerState(System.Boolean)">
            <summary>
            Проверяет состояние контейнера при выполнении какого-либо действия.
            Если состояние не соостветствует действию, то выбрасывается исключение
            </summary>
            <param name="onEdit">Действие делает изменения в контейнере</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.CheckContainerStateBool(System.Boolean)">
            <summary>
            Проверяет состояние контейнера при выполнении какого-либо действия.
            Сообщает, возможно ли выполнить данное действие.
            </summary>
            <param name="onEdit">Действие делает изменения в контейнере</param>
            <returns>Можно ли выполнить действие</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.TransformInstMode(Core.ServiceClasses.IoC.ObjectInstantiationMode,Core.ServiceClasses.IoC.OverrideObjectInstantiationMode)">
            <summary>
            Преобразовывает режим инстанцирования на основе данных переопределения
            </summary>
            <param name="src">Исходный режим инстанцирования</param>
            <param name="overrideMod">В какой режим переопределить</param>
            <returns>Переопределённый режим инстанцирования</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.AddAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Добавить ассоциацию в контейнер (с перезаписью существующего)
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.TryAddAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Попытаться добавить ассоциацию в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта</param>
            <returns>Удалось ли добавить</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.AddAssociation(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Добавить ассоциацию в контейнер с использованием фабрики формирования Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, разрешаемый по ключу</param>
            <param name="val">Фабрика созадания Lifetime контейнера</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.TryAddAssociation(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Попытаться добавить ассоциацию в контейнер с использованием фабрики формирования Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, разрешаемый по ключу</param>
            <param name="val">Фабрика созадания Lifetime контейнера</param>
            <returns>Удалось ли добавить</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.RemoveAssociation(`0)">
            <summary>
            Удалить ассоциацию из контейнера
            </summary>
            <param name="key">Ключ</param>
            <returns>Удалилась ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.Contains(`0)">
            <summary>
            Содержит ли контейнер ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.AddTypeRangeWithStrictAttr``1(System.Collections.Generic.IEnumerable{System.Type},System.Func{``0,System.Boolean},System.Action{System.Type,``0},System.Boolean)">
            <summary>
            Выполняет поиск подходящих типов для добавления в контейнер
            </summary>
            <typeparam name="TAttr">Тип аттрибута, который ищется на типе</typeparam>
            <param name="typeSource">Перечень типов, которые будут проверяться</param>
            <param name="attrCmpPredicate">Предикат для отсеивания типов с не подходящими атрибутами</param>
            <param name="procAction">Действие, которое выполняется для каждого найденного типа</param>
            <param name="multiAttr">Разрешить обработку множества атрибутов на типе (false - после обработки 1-ого сразу уходим на следующий тип)</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.AddTypeRangeWithStrictAttrPlain``1(System.Collections.Generic.IEnumerable{System.Type},System.Func{``0,System.Boolean},System.Func{System.Type,``0,`0},Core.ServiceClasses.IoC.OverrideObjectInstantiationMode,System.Boolean,System.Boolean)">
            <summary>
            Добавить в контейнер типы на основе сканирования перечня типов
            </summary>
            <typeparam name="TAttr">Тип проверяемого атрибута, который должен быть определён на типе</typeparam>
            <param name="typeSource">Перечень проверяемых типов</param>
            <param name="attrCmpPredicate">Предикат для отсеивания типов с не подходящими атрибутами</param>
            <param name="keyGenerator">Функция извлечения ключа для добавления в контейнер</param>
            <param name="modeOver">Переопределение режима инстанцирования</param>
            <param name="multiAttr">Разрешить обработку множества атрибутов на типе</param>
            <param name="combineIfPossible">Использовать единый Lifetime контейнер для объектов одного типа, если возможно</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.Core#ServiceClasses#IoC#Associations#IAssociationSource{TKey}#GetAssociation(`0)">
            <summary>
            Получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <returns>Контейнер управления жизнью объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.Core#ServiceClasses#IoC#Associations#IAssociationSource{TKey}#TryGetAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>
            Попытаться получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.Core#ServiceClasses#IoC#Associations#IAssociationSource{TKey}#Contains(`0)">
            <summary>
            Содержит ли контейнер ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.Freeze">
            <summary>
            Заморозить контейнер инъекций
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.Dispose(System.Boolean)">
            <summary>
            Внутреннее освобождение ресурсов
            </summary>
            <param name="isUserCall">True - вызвано пользователем, False - вызвано деструктором</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.Dispose">
            <summary>
            Освобождение ресурсов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.IsFrozen">
            <summary>
            Заморожен ли контейнер инъекций
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBase`1.IsDisposed">
            <summary>
            Освобождены ли ресурсы контейнера инъекций
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.#ctor">
            <summary>
            Конструктор ConcurrentGenericAssociationContainer
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.AddAssociationInner(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Внутренний метод добавления ассоциации
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.TryAddAssociationInner(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Внутренний метод попытки добавить ассоциацию в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.AddAssociationInner(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Внутренний метод добавления ассоциации в контейнер с использованием фабрики формирования Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, разрешаемый по ключу</param>
            <param name="val">Фабрика созадания Lifetime контейнера</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.TryAddAssociationInner(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Внутренний метод попытки добавления ассоциации в контейнер с использованием фабрики формирования Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, разрешаемый по ключу</param>
            <param name="val">Фабрика созадания Lifetime контейнера</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.TryGetAssociationInner(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>
            Внетренний метод попытки получить ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.RemoveAssociationInner(`0)">
            <summary>
            Внутренний метод удаления ассоциации из контейнера
            </summary>
            <param name="key">Ключ</param>
            <returns>Удалили ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.ContainsInner(`0)">
            <summary>
            Внутренний метод проверки наличия ассоциации в контейнере
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.Contains(`0)">
            <summary>
            Содержит ли контейнер ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.Core#ServiceClasses#IoC#Associations#IAssociationSource{TKey}#GetAssociation(`0)">
            <summary>
            Получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <returns>Контейнер управления жизнью объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.Core#ServiceClasses#IoC#Associations#IAssociationSource{TKey}#TryGetAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>
            Попытаться получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.Core#ServiceClasses#IoC#Associations#IAssociationSource{TKey}#Contains(`0)">
            <summary>
            Содержит ли контейнер ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.GetAssociation(`0)">
            <summary>
            Получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <returns>Контейнер управления жизнью объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.TryGetAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>
            Попытаться получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainer`1.Dispose(System.Boolean)">
            <summary>
            Внутреннее освобождение ресурсов
            </summary>
            <param name="isUserCall">True - вызвано пользователем, False - вызвано деструктором</param>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainerCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ConcurrentGenericAssociationContainerCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1">
            <summary>
            Контейнер ассоциаций для IoC с произвольным типом ключа.
            Подходит для однопоточных сценариев и многопоточных сценариев с обязательным замораживанием доступа
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.#ctor">
            <summary>
            Конструктор FreezeRequiredGenericAssociationContainer
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.AddAssociationInner(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Внутренний метод добавления ассоциации
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.TryAddAssociationInner(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Внутренний метод попытки добавить ассоциацию в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.AddAssociationInner(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Внутренний метод добавления ассоциации в контейнер с использованием фабрики формирования Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, разрешаемый по ключу</param>
            <param name="val">Фабрика созадания Lifetime контейнера</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.TryAddAssociationInner(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Внутренний метод попытки добавления ассоциации в контейнер с использованием фабрики формирования Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, разрешаемый по ключу</param>
            <param name="val">Фабрика созадания Lifetime контейнера</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.TryGetAssociationInner(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>
            Внетренний метод попытки получить ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.RemoveAssociationInner(`0)">
            <summary>
            Внутренний метод удаления ассоциации из контейнера
            </summary>
            <param name="key">Ключ</param>
            <returns>Удалили ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.ContainsInner(`0)">
            <summary>
            Внутренний метод проверки наличия ассоциации в контейнере
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.Contains(`0)">
            <summary>
            Содержит ли контейнер ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.Core#ServiceClasses#IoC#Associations#IAssociationSource{TKey}#GetAssociation(`0)">
            <summary>
            Получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <returns>Контейнер управления жизнью объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.Core#ServiceClasses#IoC#Associations#IAssociationSource{TKey}#TryGetAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>
            Попытаться получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.Core#ServiceClasses#IoC#Associations#IAssociationSource{TKey}#Contains(`0)">
            <summary>
            Содержит ли контейнер ассоциацию
            </summary>
            <param name="key">Ключ</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.GetAssociation(`0)">
            <summary>
            Получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <returns>Контейнер управления жизнью объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.TryGetAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>
            Попытаться получить ассоциацию в виде контейнера управления жизнью объекта
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Контейнер управления жизнью объекта, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainer`1.Dispose(System.Boolean)">
            <summary>
            Внутреннее освобождение ресурсов
            </summary>
            <param name="isUserCall">True - вызвано пользователем, False - вызвано деструктором</param>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainerCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.FreezeRequiredGenericAssociationContainerCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBaseCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.GenericAssociationContainerBaseCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IAssociationSourceCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IAssociationSourceCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IAssociationSourceCodeContractCheck`1.GetAssociation(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IAssociationSourceCodeContractCheck`1.TryGetAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase@)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IAssociationSourceCodeContractCheck`1.Contains(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.ICustomAssociationSupport`1">
            <summary>
            Интерфейс для поддержки добавления произвольных Lifetime контейнеров в контейнер ассоциаций
            </summary>
            <typeparam name="TKey">Тип ключа контейнера ассоциаций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ICustomAssociationSupport`1.AddAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Добавить ассоциацию с заднным Lifetime контейнером
            </summary>
            <param name="key">Ключ</param>
            <param name="lifetimeContainer">Lifetime контейнер</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ICustomAssociationSupport`1.AddAssociation(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ICustomAssociationSupport`1.TryAddAssociation(`0,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Попытаться добавить ассоциацию с заднным Lifetime контейнером
            </summary>
            <param name="key">Ключ</param>
            <param name="lifetimeContainer">Lifetime контейнер</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ICustomAssociationSupport`1.TryAddAssociation(`0,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Попытаться добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.ISingletonAssociationSupport`1">
            <summary>
            Интерфейс поддержки добавления синглтонов в контейнер ассоциаций
            </summary>
            <typeparam name="TKey">Тип ключа контейнера ассоциаций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ISingletonAssociationSupport`1.AddSingleton(`0,System.Type)">
            <summary>
            Добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип синглтона</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ISingletonAssociationSupport`1.TryAddSingleton(`0,System.Type)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IDirectSingletonAssociationSupport`1">
            <summary>
            Интерфейс поддержки добавления синглтонов как уже созданный объектов в контейнер ассоциаций
            </summary>
            <typeparam name="TKey">Тип ключа контейнера ассоциаций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IDirectSingletonAssociationSupport`1.AddSingleton(`0,System.Object)">
            <summary>
            Добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IDirectSingletonAssociationSupport`1.TryAddSingleton(`0,System.Object)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IDeferedSingletonAssociationSupport`1">
            <summary>
            Интерфейс поддержки добавления синглтонов с отложенной инициализацией в контейнер ассоциаций
            </summary>
            <typeparam name="TKey">Тип ключа контейнера ассоциаций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IDeferedSingletonAssociationSupport`1.AddDeferedSingleton(`0,System.Type)">
            <summary>
            Добавить синглтон отложенной инициализации
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип синглтона</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IDeferedSingletonAssociationSupport`1.TryAddDeferedSingleton(`0,System.Type)">
            <summary>
            Попытаться добавить синглтон отложенной инициализации
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IPerThreadAssociationSupport`1">
            <summary>
            Интерфейс поддержки добавления PerThread объектов в контейнер ассоциаций
            </summary>
            <typeparam name="TKey">Тип ключа контейнера ассоциаций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IPerThreadAssociationSupport`1.AddPerThread(`0,System.Type)">
            <summary>
            Добавить PerThread
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IPerThreadAssociationSupport`1.TryAddPerThread(`0,System.Type)">
            <summary>
            Попытаться добавить PerThread
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IPerCallAssociationSupport`1">
            <summary>
            Интерфейс поддержки добавления PerCall объектов в контейнер ассоциаций
            </summary>
            <typeparam name="TKey">Тип ключа контейнера ассоциаций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IPerCallAssociationSupport`1.AddPerCall(`0,System.Type)">
            <summary>
            Добавить PerCall
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IPerCallAssociationSupport`1.TryAddPerCall(`0,System.Type)">
            <summary>
            Попытаться добавить PerCall
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IPerCallInlinedParamsAssociationSupport`1">
            <summary>
            Интерфейс поддержки добавления PerCall объектов с зашитыми параметрами созданий в контейнер ассоциаций
            </summary>
            <typeparam name="TKey">Тип ключа контейнера ассоциаций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IPerCallInlinedParamsAssociationSupport`1.AddPerCallInlinedParams(`0,System.Type)">
            <summary>
            Добавить PerCall с зашитыми параметрами создания
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IPerCallInlinedParamsAssociationSupport`1.TryAddPerCallInlinedParams(`0,System.Type)">
            <summary>
            Попытаться добавить PerCall с зашитыми параметрами создания
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.ICustomAssociationSupportCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ICustomAssociationSupportCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.ISingletonAssociationSupportCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.ISingletonAssociationSupportCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IDirectSingletonAssociationSupportCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IDirectSingletonAssociationSupportCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IDeferedSingletonAssociationSupportCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IDeferedSingletonAssociationSupportCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IPerThreadAssociationSupportCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IPerThreadAssociationSupportCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IPerCallAssociationSupportCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IPerCallAssociationSupportCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.IPerCallInlinedParamsAssociationSupportCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.IPerCallInlinedParamsAssociationSupportCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer">
            <summary>
            Контейнер ассоциаций с ключём типа Type.
            Поддерживает многопоточность
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.AddSingleton(System.Type,System.Object)">
            <summary>
            Добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.AddSingleton(System.Type,System.Object,System.Boolean)">
            <summary>
            Добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
            <param name="disposeWithContainer">Освобождать ли объект синглтона вместе с контейнером</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.TryAddSingleton(System.Type,System.Object)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.TryAddSingleton(System.Type,System.Object,System.Boolean)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
            <param name="disposeWithContainer">Освобождать ли объект синглтона вместе с контейнером</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.AddAssociation(System.Type,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Добавить ассоциацию с заднным Lifetime контейнером
            </summary>
            <param name="key">Ключ</param>
            <param name="lifetimeContainer">Lifetime контейнер</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.AddAssociation(System.Type,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.TryAddAssociation(System.Type,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Попытаться добавить ассоциацию с заднным Lifetime контейнером
            </summary>
            <param name="key">Ключ</param>
            <param name="lifetimeContainer">Lifetime контейнер</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.TryAddAssociation(System.Type,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Попытаться добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.AddSingleton(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'синглтон'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.TryAddSingleton(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'синглтон'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.AddDeferedSingleton(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.TryAddDeferedSingleton(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.AddPerThread(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.TryAddPerThread(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.AddPerCall(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.TryAddPerCall(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.AddPerCallInlinedParams(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationContainer.TryAddPerCallInlinedParams(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension">
            <summary>
            Расширение интерфейсов поддержки добавления ассоциаций в контейнер ассоциаций
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddSingleton``2(Core.ServiceClasses.IoC.Associations.IDirectSingletonAssociationSupport{System.Type},``1)">
            <summary>
            Добавить синглтон
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Реальный тип синглтона</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="val">Значение синглтона</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddSingleton``2(Core.ServiceClasses.IoC.Associations.ISingletonAssociationSupport{System.Type})">
            <summary>
            Добавить синглтон
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Реальный тип синглтона</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddDeferedSingleton``2(Core.ServiceClasses.IoC.Associations.IDeferedSingletonAssociationSupport{System.Type})">
            <summary>
            Добавить синглтон с отложенной инициализацией
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Реальный тип синглтона</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddPerThread``2(Core.ServiceClasses.IoC.Associations.IPerThreadAssociationSupport{System.Type})">
            <summary>
            Добавить объект на поток
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Реальный тип объекта</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddPerCall``2(Core.ServiceClasses.IoC.Associations.IPerCallAssociationSupport{System.Type})">
            <summary>
            Добавить объект PerCall
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Реальный тип объекта</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddPerCallInlinedParams``2(Core.ServiceClasses.IoC.Associations.IPerCallInlinedParamsAssociationSupport{System.Type})">
            <summary>
            Добавить объект PerCall с зашитыми параметрами создания
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Реальный тип объекта</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddAssociation``1(Core.ServiceClasses.IoC.Associations.ICustomAssociationSupport{System.Type},Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Добавить ассоциацию
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="lifetimeContainer">Lifetime контейнер</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddAssociation``1(Core.ServiceClasses.IoC.Associations.ICustomAssociationSupport{System.Type},System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Добавить ассоциацию
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddSingleton``1(Core.ServiceClasses.IoC.Associations.ISingletonAssociationSupport{System.Type},System.Type)">
            <summary>
            Добавить синглтон
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddDeferedSingleton``1(Core.ServiceClasses.IoC.Associations.IDeferedSingletonAssociationSupport{System.Type},System.Type)">
            <summary>
            Добавить синглтон с отложенной инициализацией
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddPerThread``1(Core.ServiceClasses.IoC.Associations.IPerThreadAssociationSupport{System.Type},System.Type)">
            <summary>
            Добавить объект с копией на каждый поток
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddPerCall``1(Core.ServiceClasses.IoC.Associations.IPerCallAssociationSupport{System.Type},System.Type)">
            <summary>
            Добавить с копией на каждый вызов
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.AddPerCallInlinedParams``1(Core.ServiceClasses.IoC.Associations.IPerCallInlinedParamsAssociationSupport{System.Type},System.Type)">
            <summary>
            Добавить с копией на каждый вызов с зашитыми параметрами создания
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddSingleton``2(Core.ServiceClasses.IoC.Associations.IDirectSingletonAssociationSupport{System.Type},``1)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Тип синглтона</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="val">Значение синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddSingleton``2(Core.ServiceClasses.IoC.Associations.ISingletonAssociationSupport{System.Type})">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Тип синглтона</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddDeferedSingleton``2(Core.ServiceClasses.IoC.Associations.IDeferedSingletonAssociationSupport{System.Type})">
            <summary>
            Попытаться добавить синглтон с отложенной инициализацией
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Тип синглтона</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddPerThread``2(Core.ServiceClasses.IoC.Associations.IPerThreadAssociationSupport{System.Type})">
            <summary>
            Попытаться добавить PerThread
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Тип объекта</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddPerCall``2(Core.ServiceClasses.IoC.Associations.IPerCallAssociationSupport{System.Type})">
            <summary>
            Попытаться добавить PerCall
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Тип объекта</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddPerCallInlinedParams``2(Core.ServiceClasses.IoC.Associations.IPerCallInlinedParamsAssociationSupport{System.Type})">
            <summary>
            Попытаться добавить PerCall с зашитыми параметрами создания
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TTarg">Тип объекта</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddAssociation``1(Core.ServiceClasses.IoC.Associations.ICustomAssociationSupport{System.Type},Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Попытаться добавить ассоциацию
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="lifetimeContainer">Lifetime контейнер</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddAssociation``1(Core.ServiceClasses.IoC.Associations.ICustomAssociationSupport{System.Type},System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Попытаться добавить ассоциацию
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddSingleton``1(Core.ServiceClasses.IoC.Associations.ISingletonAssociationSupport{System.Type},System.Type)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddDeferedSingleton``1(Core.ServiceClasses.IoC.Associations.IDeferedSingletonAssociationSupport{System.Type},System.Type)">
            <summary>
            Попытаться добавить синглтон с отложенной инициализацией
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddPerThread``1(Core.ServiceClasses.IoC.Associations.IPerThreadAssociationSupport{System.Type},System.Type)">
            <summary>
            Попытаться добавить PerThread
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddPerCall``1(Core.ServiceClasses.IoC.Associations.IPerCallAssociationSupport{System.Type},System.Type)">
            <summary>
            Попытаться добавить PerCall
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictAssociationExtension.TryAddPerCallInlinedParams``1(Core.ServiceClasses.IoC.Associations.IPerCallInlinedParamsAssociationSupport{System.Type},System.Type)">
            <summary>
            Попытаться добавить PerCall с зашитыми параметрами инициализации
            </summary>
            <typeparam name="TSrc">Тип, используемый в качестве ключа</typeparam>
            <param name="obj">Контейнер ассоциаций</param>
            <param name="objType">Тип объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer">
            <summary>
            Контейнер ассоциаций с ключём типа Type.
            Годен для однопоточных сценариев и многопоточных с обязательной заморозкой
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.AddSingleton(System.Type,System.Object)">
            <summary>
            Добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.AddSingleton(System.Type,System.Object,System.Boolean)">
            <summary>
            Добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
            <param name="disposeWithContainer">Освобождать ли объект синглтона вместе с контейнером</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.TryAddSingleton(System.Type,System.Object)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.TryAddSingleton(System.Type,System.Object,System.Boolean)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект синглтона</param>
            <param name="disposeWithContainer">Освобождать ли объект синглтона вместе с контейнером</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.AddAssociation(System.Type,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Добавить ассоциацию с заднным Lifetime контейнером
            </summary>
            <param name="key">Ключ</param>
            <param name="lifetimeContainer">Lifetime контейнер</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.AddAssociation(System.Type,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.TryAddAssociation(System.Type,Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Попытаться добавить ассоциацию с заднным Lifetime контейнером
            </summary>
            <param name="key">Ключ</param>
            <param name="lifetimeContainer">Lifetime контейнер</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.TryAddAssociation(System.Type,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Попытаться добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.AddSingleton(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'синглтон'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.TryAddSingleton(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'синглтон'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.AddDeferedSingleton(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.TryAddDeferedSingleton(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.AddPerThread(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.TryAddPerThread(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.AddPerCall(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.TryAddPerCall(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.AddPerCallInlinedParams(System.Type,System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.TypeStrictFreezeRequiredAssociationContainer.TryAddPerCallInlinedParams(System.Type,System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.CommonObjectLocator">
            <summary>
            Локатор объектов для общего случая (когда тип аллоцируемого объекта является дочерним к типу ключа)
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.IObjectLocator`1">
            <summary>
            Интерфейс локатора объектов
            </summary>
            <typeparam name="TKey">Тип ключа локатора</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.IObjectLocator`1.Resolve(`0)">
            <summary>
            Получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.IObjectLocator`1.TryResolve(`0,System.Object@)">
            <summary>
            Попытаться получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.IObjectLocator`1.CanResolve(`0)">
            <summary>
            Можно ли получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Можно ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Конструктор CommonObjectLocator
            </summary>
            <param name="useAssocAsDISource">Использовать ли ассоциации как источник инъекций (возможно переполнение стека в случае ошибок)</param>
            <param name="disposeInjectionWithBuilder">Освобождать ли все инъекции с контейнером</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.#ctor">
            <summary>
            Конструктор CommonObjectLocator
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.Resolve``1">
            <summary>
            Получить объект по его типу
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <returns>Полученное значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.TryResolve``1(``0@)">
            <summary>
            Попытаться получить объект по его типу
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="val">Полученное значение в случае успеха</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.CanResolve``1">
            <summary>
            Можно ли получить объект по его типу
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <returns>Можно ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.CreateObject``1">
            <summary>
            Создаёт объект типа T с использованием инъекций
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.Resolve(System.Type)">
            <summary>
            Получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.TryResolve(System.Type,System.Object@)">
            <summary>
            Попытаться получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.CanResolve(System.Type)">
            <summary>
            Можно ли получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Можно ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.Core#ServiceClasses#IoC#IObjectLocator{System#Type}#Resolve(System.Type)">
            <summary>
            Получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.Core#ServiceClasses#IoC#IObjectLocator{System#Type}#TryResolve(System.Type,System.Object@)">
            <summary>
            Попытаться получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.Core#ServiceClasses#IoC#IObjectLocator{System#Type}#CanResolve(System.Type)">
            <summary>
            Можно ли получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Можно ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.Dispose(System.Boolean)">
            <summary>
            Внутреннее освобождение ресурсов
            </summary>
            <param name="isUserCall">True - вызвано пользователем, False - вызвано деструктором</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.Dispose">
            <summary>
            Освобождение ресурсов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.CommonObjectLocator.Injection">
            <summary>
            Контейнер инъекций
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.CommonObjectLocator.Association">
            <summary>
            Контейнер ассоциаций
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.CommonObjectLocator.InjectionThenAssociationResolver">
            <summary>
            Специальный резолвер инъекций, который сначала проверяет в контейнере инъекций, а потом в контейнере ассоциаций
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver">
            <summary>
            Интерфейс для разрешения зависимостей
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver.Resolve(System.Type,System.String,System.Type,System.Object)">
            <summary>
            Разрешить зависимость на основе подробной информации
            </summary>
            <param name="reqObjectType">Тип объекта, который требуется вернуть</param>
            <param name="paramName">Имя параметра, для которого разрешается зависимость (если применимо)</param>
            <param name="forType">Тип, для которого разрешается зависимость (если применимо)</param>
            <param name="extData">Расширенные данные для разрешения зависимости (если есть)</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver.Resolve``1(System.Type)">
            <summary>
            Упрощённое разрешение зависимости
            </summary>
            <typeparam name="T">Тип объекта, который требуется вернуть</typeparam>
            <param name="forType">Тип, для которого разрешается зависимость</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.InjectionThenAssociationResolver.#ctor(Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer,Core.ServiceClasses.IoC.CommonObjectLocator)">
            <summary>
            Конструктор InjectionThenAssociationResolver
            </summary>
            <param name="srcInj">Контейнер инъекций</param>
            <param name="locator">Локатор</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.InjectionThenAssociationResolver.Resolve(System.Type,System.String,System.Type,System.Object)">
            <summary>
            Разрешить зависимость на основе подробной информации
            </summary>
            <param name="reqObjectType">Тип объекта, который требуется вернуть</param>
            <param name="paramName">Имя параметра, для которого разрешается зависимость (если применимо)</param>
            <param name="forType">Тип, для которого разрешается зависимость (если применимо)</param>
            <param name="extData">Расширенные данные для разрешения зависимости (если есть)</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.CommonObjectLocator.InjectionThenAssociationResolver.Resolve``1(System.Type)">
            <summary>
            Упрощённое разрешение зависимости
            </summary>
            <typeparam name="T">Тип объекта, который требуется вернуть</typeparam>
            <param name="forType">Тип, для которого разрешается зависимость</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer">
            <summary>
            Контейнер ассоциаций, в котором ключ - тип, являющийся базовым для типа значения (делает разрешение по иерархии наследования)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.#ctor(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Конструктор DirectTypeAssociationContainer
            </summary>
            <param name="injResolver">Резолвер инъекций</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.ProduceResolveInfo(System.Type,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Сформировать Lifetime контейнер по типу и фабрике 
            </summary>
            <param name="key">Ключ, по которому будет сохранён контейнер</param>
            <param name="objType">Тип объекта, который будет обрабатывать Lifetime контейнер</param>
            <param name="val">Фабрика для создания Lifetime контейнера</param>
            <returns>Lifetime контейнер</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.IsGoodTypeForKey(System.Type,System.Type)">
            <summary>
            Подходит ли переданный тип для заданного ключа
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта</param>
            <returns>Подходит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddSingleton``1(``0)">
            <summary>
            Добавить синглтон
            </summary>
            <typeparam name="TType">Тип синглтона</typeparam>
            <param name="val">Значение синглтона</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddSingleton``1(``0,System.Boolean)">
            <summary>
            Добавить синглтон
            </summary>
            <typeparam name="TType">Тип синглтона</typeparam>
            <param name="val">Значение синглтона</param>
            <param name="disposeWithContainer">Освобождать ли объект синглтона вместе с контейнером</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddSingleton``1(``0)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <typeparam name="TType">Тип синглтона</typeparam>
            <param name="val">Значение синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddSingleton``1(``0,System.Boolean)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <typeparam name="TType">Тип синглтона</typeparam>
            <param name="val">Значение синглтона</param>
            <param name="disposeWithContainer">Освобождать ли объект синглтона вместе с контейнером</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddAssociation``1(Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Добавить ассоциацию
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="lifetimeContainer">Lifetime контейнер</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddAssociation``1(System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Добавить ассоциацию
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddAssociation``1(Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Попытаться добавить ассоциацию
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="lifetimeContainer">Lifetime контейнер</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddAssociation``1(System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Попытаться добавить ассоциацию
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddAssociation``2(Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TValue">Тип объекта, которым будет управлять Lifetime контейнер</typeparam>
            <param name="factory">Фабрика</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddAssociation``2(Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Попытаться добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TValue">Тип объекта, которым будет управлять Lifetime контейнер</typeparam>
            <param name="factory">Фабрика</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddSingleton``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'синглтон'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddSingleton``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'синглтон'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddSingleton``2">
            <summary>
            Добавить ассоциацию типа 'синглтон'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddSingleton``2">
            <summary>
            Попытаться добавить ассоциацию типа 'синглтон'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddDeferedSingleton``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddDeferedSingleton``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddDeferedSingleton``2">
            <summary>
            Добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddDeferedSingleton``2">
            <summary>
            Попытаться добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddPerThread``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddPerThread``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddPerThread``2">
            <summary>
            Добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddPerThread``2">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddPerCall``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddPerCall``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddPerCall``2">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddPerCall``2">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddPerCallInlinedParams``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddPerCallInlinedParams``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.AddPerCallInlinedParams``2">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Associations.DirectTypeAssociationContainer.TryAddPerCallInlinedParams``2">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.SimpleObjectLocator">
            <summary>
            Простой локатор объектов
            Инъекции имитируются синглтонами
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.#ctor">
            <summary>
            Конструктор SimpleObjectLocator
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.ProduceResolveInfo(System.Type,System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Сформировать Lifetime контейнер по типу и фабрике 
            </summary>
            <param name="key">Ключ, по которому будет сохранён контейнер</param>
            <param name="objType">Тип объекта, который будет обрабатывать Lifetime контейнер</param>
            <param name="val">Фабрика для создания Lifetime контейнера</param>
            <returns>Lifetime контейнер</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.IsGoodTypeForKey(System.Type,System.Type)">
            <summary>
            Подходит ли переданный тип для заданного ключа
            </summary>
            <param name="key">Ключ</param>
            <param name="objType">Тип объекта</param>
            <returns>Подходит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddSingleton``1(``0)">
            <summary>
            Добавить синглтон
            </summary>
            <typeparam name="TType">Тип синглтона</typeparam>
            <param name="val">Значение синглтона</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddSingleton``1(``0,System.Boolean)">
            <summary>
            Добавить синглтон
            </summary>
            <typeparam name="TType">Тип синглтона</typeparam>
            <param name="val">Значение синглтона</param>
            <param name="disposeWithContainer">Освобождать ли объект синглтона вместе с контейнером</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddSingleton``1(``0)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <typeparam name="TType">Тип синглтона</typeparam>
            <param name="val">Значение синглтона</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddSingleton``1(``0,System.Boolean)">
            <summary>
            Попытаться добавить синглтон
            </summary>
            <typeparam name="TType">Тип синглтона</typeparam>
            <param name="val">Значение синглтона</param>
            <param name="disposeWithContainer">Освобождать ли объект синглтона вместе с контейнером</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddAssociation``1(Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Добавить ассоциацию
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="lifetimeContainer">Lifetime контейнер</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddAssociation``1(System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Добавить ассоциацию
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddAssociation``1(Core.ServiceClasses.IoC.Lifetime.LifetimeBase)">
            <summary>
            Попытаться добавить ассоциацию
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="lifetimeContainer">Lifetime контейнер</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddAssociation``1(System.Type,Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Попытаться добавить ассоциацию
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип объекта, которым будет управлять Lifetime контейнер</param>
            <param name="factory">Фабрика</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddAssociation``2(Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TValue">Тип объекта, которым будет управлять Lifetime контейнер</typeparam>
            <param name="factory">Фабрика</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddAssociation``2(Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory)">
            <summary>
            Попытаться добавить ассоциацию для заданного типа и фабрики создания Lifetime контейнера
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <typeparam name="TValue">Тип объекта, которым будет управлять Lifetime контейнер</typeparam>
            <param name="factory">Фабрика</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddSingleton``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'синглтон'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddSingleton``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'синглтон'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddSingleton``2">
            <summary>
            Добавить ассоциацию типа 'синглтон'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddSingleton``2">
            <summary>
            Попытаться добавить ассоциацию типа 'синглтон'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddDeferedSingleton``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddDeferedSingleton``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddDeferedSingleton``2">
            <summary>
            Добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddDeferedSingleton``2">
            <summary>
            Попытаться добавить ассоциацию типа 'отложенный синглтон'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddPerThread``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddPerThread``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddPerThread``2">
            <summary>
            Добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddPerThread``2">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на поток'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddPerCall``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddPerCall``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddPerCall``2">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddPerCall``2">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddPerCallInlinedParams``1(System.Type)">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddPerCallInlinedParams``1(System.Type)">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <typeparam name="TKey">Тип, используемый в качестве ключа</typeparam>
            <param name="objType">Тип инстанцируемого объекта</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.AddPerCallInlinedParams``2">
            <summary>
            Добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryAddPerCallInlinedParams``2">
            <summary>
            Попытаться добавить ассоциацию типа 'экземпляр на каждый вызов с зашитыми параметрами инстанцирования'
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип инстанцируемого объекта</typeparam>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.Resolve(System.Type)">
            <summary>
            Получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryResolve(System.Type,System.Object@)">
            <summary>
            Попытаться получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.CanResolve(System.Type)">
            <summary>
            Можно ли получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Можно ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.Resolve``1">
            <summary>
            Получить объект по его типу
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <returns>Полученное значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.TryResolve``1(``0@)">
            <summary>
            Попытаться получить объект по его типу
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="val">Полученное значение в случае успеха</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.CreateObject``1">
            <summary>
            Создаёт объект типа T с использованием инъекций
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.CanResolve``1">
            <summary>
            Можно ли получить объект по его типу
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <returns>Можно ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.Core#ServiceClasses#IoC#IObjectLocator{System#Type}#Resolve(System.Type)">
            <summary>
            Получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.Core#ServiceClasses#IoC#IObjectLocator{System#Type}#TryResolve(System.Type,System.Object@)">
            <summary>
            Попытаться получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.Core#ServiceClasses#IoC#IObjectLocator{System#Type}#CanResolve(System.Type)">
            <summary>
            Можно ли получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Можно ли</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.SimpleObjectLocator.InnerInjectionResolver">
            <summary>
            Объект для резолва инъекций
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.InnerInjectionResolver.#ctor(Core.ServiceClasses.IoC.SimpleObjectLocator)">
            <summary>
            Конструктор InnerInjectionResolver
            </summary>
            <param name="locator">Локатор</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.InnerInjectionResolver.Resolve(System.Type,System.String,System.Type,System.Object)">
            <summary>
            Разрешить зависимость на основе подробной информации
            </summary>
            <param name="reqObjectType">Тип объекта, который требуется вернуть</param>
            <param name="paramName">Имя параметра, для которого разрешается зависимость (если применимо)</param>
            <param name="forType">Тип, для которого разрешается зависимость (если применимо)</param>
            <param name="extData">Расширенные данные для разрешения зависимости (если есть)</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.SimpleObjectLocator.InnerInjectionResolver.Resolve``1(System.Type)">
            <summary>
            Упрощённое разрешение зависимости
            </summary>
            <typeparam name="T">Тип объекта, который требуется вернуть</typeparam>
            <param name="forType">Тип, для которого разрешается зависимость</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.ObjectInstantiationMode">
            <summary>
            Способ инстанцирования объекта
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.ObjectInstantiationMode.Singleton">
            <summary>
            Использовать единую копию объекта
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.ObjectInstantiationMode.DeferedSingleton">
            <summary>
            Единая копия объекта с инициализацией при первом обращении
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.ObjectInstantiationMode.PerThread">
            <summary>
            Одна копия объекта на каждый поток
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.ObjectInstantiationMode.PerCall">
            <summary>
            Создавать объект при каждом вызове
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.ObjectInstantiationMode.PerCallInlinedParams">
            <summary>
            Создавать объект при каждом вызове, но параметры конструктора получить лишь 1 раз при инициализации
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.OverrideObjectInstantiationMode">
            <summary>
            Переопределение режима инстанцирования
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.OverrideObjectInstantiationMode.None">
            <summary>
            Не переопределять
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.OverrideObjectInstantiationMode.ToSingleton">
            <summary>
            Переопределить в режим 'использование одной копии'
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.OverrideObjectInstantiationMode.ToDeferedSingleton">
            <summary>
            Переопределить в режим 'отложенный синглтон'
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.OverrideObjectInstantiationMode.ToPerThread">
            <summary>
            Переопределить в режим 'объект на поток'
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.OverrideObjectInstantiationMode.ToPerCall">
            <summary>
            Переопределить в режим 'создания на каждый вызов'
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.OverrideObjectInstantiationMode.ToPerCallInlinedParams">
            <summary>
            Переопределить в режим 'создания на каждый вызов с зашитыми параметрами'
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.DefaultConstructorAttribute">
            <summary>
            Атрибут, помечающий конструктор, который будет использован для автоматического создания объекта
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper">
            <summary>
            Набор вспомогательных методов для работы через Reflection
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.FindConstructor(System.Type,System.Boolean)">
            <summary>
            Ищет конструктор для объекта
            </summary>
            <param name="executerType">Тип объекта</param>
            <param name="onlyPublic">Искать только public конструкторы</param>
            <returns>Информация о конструкторе</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.CreateObject(System.Type,System.Reflection.ConstructorInfo,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создаёт объект определённого типа с определённым коструктором и параметрами из injection
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="injection">Интерфейс для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения зависимостей</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.CreateObject(System.Type,System.Reflection.ConstructorInfo)">
            <summary>
            Создаёт объект типа objType конструктором без параметров
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.CreateObject(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создаёт объект определённого типа с параметрами из injection
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.CreateObject(System.Type)">
            <summary>
            Создаёт объект определённого типа с помощью конструктора без параметров
            </summary>
            <param name="objType"></param>
            <returns></returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetReflectionBasedCreationFunction(System.Type,System.Reflection.ConstructorInfo,System.Object)">
            <summary>
            Возвращает функцию, которая создаёт объект типа objType при помощи рефлексии
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Функция создания объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetReflectionBasedCreationFunction(System.Type,System.Object)">
            <summary>
            Возвращает функцию, которая создаёт объект типа objType при помощи рефлексии
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Функция создания объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.ExtractMethodInfo``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Возвращает информацию о методе, вызываемом в переданном выражении
            </summary>
            <typeparam name="InstT">Тип объекта, чей метод извлекается</typeparam>
            <param name="methodCallExpr">Выражение с вызовом метода</param>
            <returns>Информация о вызываемом методе</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.ExtractMethodInfo(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Возвращает информацию о методе, вызываемом в переданном выражении
            </summary>
            <param name="methodCallExpr">Выражение с вызовом метода</param>
            <returns>Информация о вызываемом методе</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.ExtractConstructorInfo(System.Linq.Expressions.Expression{System.Action})">
            <summary>
            Возвращает информацию о конструкторе, вызываемом в переданном выражении
            </summary>
            <param name="constructorCallExpr">Выражение с созданием нового объекта</param>
            <returns>Информация о вызываемом конструкторе</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.CreateInjectionExtractionExpr(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.String,System.Type,System.Object)">
            <summary>
            Создаёт Expression для извлечения записи из конкретного объекта injection
            </summary>
            <param name="key">Ключ</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="paramName">Имя параметра, для которого разрешаем зависимость</param>
            <param name="forType">Тип, для которого разрешаем зависимость (передаётся в injection.Resolve)</param>
            <param name="extData">Расширенная информация для разрешения инъекций (передаётся в injection.Resolve)</param>
            <returns>Expression для извлечения записи</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.CreateInjectionExtractionExpr(System.Type,System.Linq.Expressions.Expression,System.String,System.Type,System.Object)">
            <summary>
            Создаёт Expression для извлечения записи из IInjectionResolver, получаемого через выражение param
            </summary>
            <param name="key">Ключ</param>
            <param name="param">Expression для получения IInjectionResolver</param>
            <param name="paramName">Имя параметра, для которого разрешаем зависимость</param>
            <param name="forType">Тип, для которого разрешаем зависимость (передаётся в injection.Resolve)</param>
            <param name="extData">Расширенная информация для разрешения инъекций (передаётся в injection.Resolve)</param>
            <returns>Expression для извлечения записи</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.CreateInjectionExtractionExpr(System.Type,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Создаёт Expression для извлечения записи из IInjectionResolver, получаемого через выражение param
            </summary>
            <param name="key">Ключ</param>
            <param name="param">Expression для получения IInjectionResolver</param>
            <param name="paramName">Expression для получения имени параметра, для которого разрешаем зависимость</param>
            <param name="forType">Expression для получения типа, для которого разрешаем зависимость (передаётся в injection.Resolve)</param>
            <param name="extData">Expression для получения расширенной информации для разрешения инъекций (передаётся в injection.Resolve)</param>
            <returns>Expression для извлечения записи</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetObjectCreationExpression(System.Type,System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression)">
            <summary>
            Возвращает LambdaExpression для создания объекта с передаваемым в качестве параметра объектом разрешения инъекций 
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="extData">Расширенные данные для разрешения инъекций</param>
            <returns>Сформированный LambdaExpression</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetCompiledCreationFunction(System.Type,System.Reflection.ConstructorInfo,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Возвращает функцию, которая создаёт объект типа objType.
            Функция представляет собой скомпилированное ExcpressionTree. 
            Аргументы извлекаются при каждом обращении из словаря инъекций injection, зашитом в данную функцию.
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Функция создания объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetCompiledCreationFunction(System.Type,System.Reflection.ConstructorInfo,System.Linq.Expressions.Expression)">
            <summary>
            Возвращает функцию, которая создаёт объект типа objType.
            Функция представляет собой скомпилированное ExcpressionTree. 
            Аргументы извлекаются при каждом обращении из словаря инъекций, передаваемом в качестве параметра
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="extData">Expression для получения расширенной информации для разрешения инъекций</param>
            <returns>Функция создания объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetCompiledCreationFunction(System.Type,System.Linq.Expressions.Expression)">
            <summary>
            Возвращает функцию, которая создаёт объект типа objType.
            Функция представляет собой скомпилированное ExcpressionTree. 
            Аргументы извлекаются при каждом обращении из словаря инъекций, передаваемом в качестве параметра
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="extData">Expression для получения расширенной информации для разрешения инъекций</param>
            <returns>Функция создания объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetCompiledCreationFunction(System.Type,System.Object)">
            <summary>
            Возвращает функцию, которая создаёт объект типа objType.
            Функция представляет собой скомпилированное ExcpressionTree. 
            Аргументы извлекаются при каждом обращении из словаря инъекций, передаваемом в качестве параметра
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Функция создания объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetCompiledArgsInlinedCreationFunction(System.Type,System.Reflection.ConstructorInfo,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Возвращает функцию, которая создаёт объект типа objType.
            Функция представляет собой скомпилированное ExcpressionTree. 
            Аргументы зашиты в функцию для ускорения процесса создания.
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Функция создания объекта</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetCompiledArgsInlinedCreationFunction(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Возвращает функцию, которая создаёт объект типа objType.
            Функция представляет собой скомпилированное ExcpressionTree. 
            Аргументы зашиты в функцию для ускорения процесса создания.
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Функция создания объекта</returns>
        </member>
        <member name="F:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper._dynamicAssembly">
            <summary>
            Динамическая сборка, внутри которой генерируются типы
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper._dynamicModule">
            <summary>
            Динамический модуль внутри _dynamicAssembly
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper._lockObjectForAssembly">
            <summary>
            Объект блокировки для создания _dynamicAssembly и _dynamicModule
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper._singleThreadAccessToDynModule">
            <summary>
            Объект блокировки при работе с _dynamicModule
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetDynamicModule">
            <summary>
            Возвращает динамический модуль для формирования типов на лету
            </summary>
            <returns>Построитель модуля</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.EmitConstructor(System.Reflection.Emit.ConstructorBuilder,System.Reflection.FieldInfo[])">
            <summary>
            Генерирует код конструктора с параметрами для заполнения полей объекта из storageFields
            </summary>
            <param name="constr">Построитель конструктора</param>
            <param name="storageFields">Поля класса, которые должны заполнятся в конструкторе из его параметров</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.EmitMethodWithResolver(System.Reflection.Emit.MethodBuilder,System.Type,System.Reflection.ConstructorInfo,System.Reflection.FieldInfo)">
            <summary>
            Генерирует код метода для создания объекта типа objType конструктором constructor с расширенной информацией в поле extData
            </summary>
            <param name="method">Построитель метода</param>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="extData">Поле, в котором хранятся расширенные параметры</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.EmitMethodWithInlinedParams(System.Reflection.Emit.MethodBuilder,System.Type,System.Reflection.ConstructorInfo,System.Reflection.FieldInfo[])">
            <summary>
            Генерирует код метода для создания объекта типа objType конструктором constructor.
            Все параметры для конструктора objType находятся в полях стоящегося объекта, переданных в массиве allFields.
            Порядок должен точно соответствовать
            </summary>
            <param name="method">Построитель метода</param>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="allFields">Массив полей, в которых хранятся параметры для конструктора объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildTypeOfInstanceCreator(System.Type,System.Reflection.ConstructorInfo)">
            <summary>
            Строит тип, реализующий интерфейс IInstanceCreator для создания объекта типа objType
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <returns>Построенный тип</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildTypeOfInstanceCreatorNoParam(System.Type,System.Reflection.ConstructorInfo)">
            <summary>
            Строит тип, реализующий интерфейс IInstanceCreatorNoParam для создания объекта типа objType.
            Параметры передаются в конструктор создаваемого объекта
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <returns>Построенный тип</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetInstanceCreatorObject(System.Type,System.Reflection.ConstructorInfo,System.Object)">
            <summary>
            Создаёт объект, реализующий IInstanceCreator, для создания объекта типа objType конструктором constructor
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.GetInstanceCreatorNoParamObject(System.Type,System.Reflection.ConstructorInfo,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создаёт объект, реализующий IInstanceCreatorNoParam, для создания объекта типа objType конструктором constructor.
            Параметры конструктора извлекаются 1 раз и зашиваются в объект.
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildInstanceCreatorInDynAssembly(System.Type,System.Reflection.ConstructorInfo,System.Object)">
            <summary>
            Создаёт объект IInstanceCreator для создания объекта типа objType конструктором constructor.
            Тип объекта генерируется на лету внутри динамической сборки
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданный объект IInstanceCreator</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildInstanceCreatorNoParamInDynAssembly(System.Type,System.Reflection.ConstructorInfo,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создаёт объект IInstanceCreatorNoParam для создания объекта типа objType конструктором constructor.
            Тип объекта генерируется на лету внутри динамической сборки.
            Параметры для конструктора выбираются 1 раз и зашиваются в объект IInstanceCreatorNoParam
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданный объект IInstanceCreatorNoParam</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildCreatorFuncInDynAssembly(System.Type,System.Reflection.ConstructorInfo,System.Object)">
            <summary>
            Создаёт функцию для создания объекта типа objType конструктором constructor.
            Тип объекта генерируется на лету внутри динамической сборки
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданная функция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildCreatorFuncNoParamInDynAssembly(System.Type,System.Reflection.ConstructorInfo,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создаёт функцию для создания объекта типа objType конструктором constructor.
            Тип объекта генерируется на лету внутри динамической сборки.
            Параметры для конструктора выбираются 1 раз и зашиваются в объект создания
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="constructor">Конструктор</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданная функция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildInstanceCreatorInDynAssembly(System.Type,System.Object)">
            <summary>
            Создаёт объект IInstanceCreator для создания объекта типа objType.
            Тип объекта генерируется на лету внутри динамической сборки
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданный объект IInstanceCreator</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildInstanceCreatorNoParamInDynAssembly(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создаёт объект IInstanceCreatorNoParam для создания объекта типа objType.
            Тип объекта генерируется на лету внутри динамической сборки.
            Параметры для конструктора выбираются 1 раз и зашиваются в объект IInstanceCreatorNoParam
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданный объект IInstanceCreatorNoParam</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildCreatorFuncInDynAssembly(System.Type,System.Object)">
            <summary>
            Создаёт функцию для создания объекта типа objType.
            Тип объекта генерируется на лету внутри динамической сборки
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданная функция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Helpers.OnjectInstantiationHelper.BuildCreatorFuncNoParamInDynAssembly(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создаёт функцию для создания объекта типа objType.
            Тип объекта генерируется на лету внутри динамической сборки.
            Параметры для конструктора выбираются 1 раз и зашиваются в объект создания
            </summary>
            <param name="objType">Тип создаваемого объекта</param>
            <param name="injection">Объект для разрешения инъекций</param>
            <param name="extData">Расширенная информация для разрешения инъекций</param>
            <returns>Созданная функция</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1">
            <summary>
            Контейнер инъекций, использующий ConcurrentDictionary для хранения.
            Подходит для многопоточных сценариев
            </summary>
            <typeparam name="TKey">Ключ разрешения инъекций</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1">
            <summary>
            Контейнер инъекций с произвольным типом ключа
            </summary>
            <typeparam name="TKey">Тип ключа</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.IInjectionSource`1">
            <summary>
            Источник инъекций
            </summary>
            <typeparam name="TKey">Тип ключа для извлечения инъекций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.IInjectionSource`1.GetInjection(`0)">
            <summary>
            Получение инъекции по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Инъекция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.IInjectionSource`1.TryGetInjection(`0,System.Object@)">
            <summary>
            Пытается получить инъекцию по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение, если найдено</param>
            <returns>Удалось ли получить значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.IInjectionSource`1.Contains(`0)">
            <summary>
            Содержит ли контейнер инъекцию
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть или нет</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.TryGetInjectionInner(`0,System.Object@)">
            <summary>
            Внутренний метод попытки извлечь инъекцию
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Полученное значение в случа успеха</param>
            <returns>Удалось ли извлечь</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.ContainsInner(`0)">
            <summary>
            Внутренний метод проверки наличия инъекции
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть ли инъекция в контейнере</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.AddInjectionInner(`0,System.Object)">
            <summary>
            Внутренний метод добавления инъекции в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.TryAddInjectionInner(`0,System.Object)">
            <summary>
            Внутренний метод попытки добавить инъекцию в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.RemoveInjectionInner(`0)">
            <summary>
            Внутренний метод удаления инъекции
            </summary>
            <param name="key">Ключ</param>
            <returns>Удалили ли инъекцию</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.CheckContainerState(System.Boolean)">
            <summary>
            Проверяет состояние контейнера при выполнении какого-либо действия.
            Если состояние не соостветствует действию, то выбрасывается исключение
            </summary>
            <param name="onEdit">Действие делает изменения в контейнере</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.CheckContainerStateBool(System.Boolean)">
            <summary>
            Проверяет состояние контейнера при выполнении какого-либо действия.
            Сообщает, возможно ли выполнить данное действие.
            </summary>
            <param name="onEdit">Действие делает изменения в контейнере</param>
            <returns>Можно ли выполнить действие</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.GetInjection(`0)">
            <summary>
            Получение инъекции по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Инъекция</returns>
            <exception cref="T:Core.ServiceClasses.InjectionIoCException">При отсутствии ключа</exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.TryGetInjection(`0,System.Object@)">
            <summary>
            Пытается получить инъекцию по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение, если найдено</param>
            <returns>Удалось ли получить значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.Contains(`0)">
            <summary>
            Содержит ли контейнер инъекцию
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть или нет</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.AddInjection(`0,System.Object)">
            <summary>
            Добавляет инъекцию в контейнер. Если она уже там есть, то перезаписывает.
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:Core.ServiceClasses.ObjectFrozenException"></exception>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.TryAddInjection(`0,System.Object)">
            <summary>
            Пытается добавить инъекцию.
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение</param>
            <returns>True если удалось, False - если инъекция с таким ключём уже была, либо если неверное состояние контейнера</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.RemoveInjection(`0)">
            <summary>
            Удаляет инъекцию из контейнера
            </summary>
            <param name="key">Ключ</param>
            <returns>Произошло ли удаление</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:Core.ServiceClasses.ObjectFrozenException"></exception>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.Core#ServiceClasses#IoC#Injections#IInjectionSource{TKey}#GetInjection(`0)">
            <summary>
            Получение инъекции по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Инъекция</returns>
            <exception cref="T:Core.ServiceClasses.InjectionIoCException">При отсутствии ключа</exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.Core#ServiceClasses#IoC#Injections#IInjectionSource{TKey}#TryGetInjection(`0,System.Object@)">
            <summary>
            Пытается получить инъекцию по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение, если найдено</param>
            <returns>Удалось ли получить значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.Core#ServiceClasses#IoC#Injections#IInjectionSource{TKey}#Contains(`0)">
            <summary>
            Содержит ли контейнер инъекцию
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть или нет</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.Freeze">
            <summary>
            Заморозить контейнер инъекций
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.Dispose(System.Boolean)">
            <summary>
            Внутреннее освобождение ресурсов
            </summary>
            <param name="isUserCall">True - вызвано пользователем, False - вызвано деструктором</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.Dispose">
            <summary>
            Освобождение ресурсов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.IsFrozen">
            <summary>
            Заморожен ли контейнер инъекций
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase`1.IsDisposed">
            <summary>
            Освобождены ли ресурсы контейнера инъекций
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.#ctor(System.Boolean)">
            <summary>
            Конструктор ConcurrentGenericInjectionContainer
            </summary>
            <param name="disposeInjectionsWithBuilder">Вызывать ли Dispose у хранимых объектов при уничтожении контейнера</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.#ctor">
            <summary>
            Конструктор ConcurrentGenericInjectionContainer
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.IsGoodInjectionForKey(`0,System.Object)">
            <summary>
            Подходит ли данная инъекция для ключа
            </summary>
            <param name="key">Ключ</param>
            <param name="injection">Инъекция</param>
            <returns>Подходит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.TryGetInjectionInner(`0,System.Object@)">
            <summary>
            Внутренний метод попытки извлечь инъекцию
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Полученное значение в случа успеха</param>
            <returns>Удалось ли извлечь</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.ContainsInner(`0)">
            <summary>
            Внутренний метод проверки наличия инъекции
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть ли инъекция в контейнере</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.AddInjectionInner(`0,System.Object)">
            <summary>
            Внутренний метод добавления инъекции в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.TryAddInjectionInner(`0,System.Object)">
            <summary>
            Внутренний метод попытки добавить инъекцию в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.RemoveInjectionInner(`0)">
            <summary>
            Внутренний метод удаления инъекции
            </summary>
            <param name="key">Ключ</param>
            <returns>Удалили ли инъекцию</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.GetInjection(`0)">
            <summary>
            Получение инъекции по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Инъекция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.TryGetInjection(`0,System.Object@)">
            <summary>
            Пытается получить инъекцию по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение, если найдено</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.Contains(`0)">
            <summary>
            Содержит ли контейнер инъекцию
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть или нет</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.Core#ServiceClasses#IoC#Injections#IInjectionSource{TKey}#GetInjection(`0)">
            <summary>
            Получение инъекции по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Инъекция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.Core#ServiceClasses#IoC#Injections#IInjectionSource{TKey}#TryGetInjection(`0,System.Object@)">
            <summary>
            Пытается получить инъекцию по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение, если найдено</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.Core#ServiceClasses#IoC#Injections#IInjectionSource{TKey}#Contains(`0)">
            <summary>
            Содержит ли контейнер инъекцию
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть или нет</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.ConcurrentGenericInjectionContainer`1.Dispose(System.Boolean)">
            <summary>
            Внутреннее освобождение ресурсов
            </summary>
            <param name="isUserCall">True - вызвано пользователем, False - вызвано деструктором</param>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBaseCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBaseCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBaseCodeContractCheck`1.TryGetInjectionInner(`0,System.Object@)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBaseCodeContractCheck`1.ContainsInner(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBaseCodeContractCheck`1.AddInjectionInner(`0,System.Object)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBaseCodeContractCheck`1.TryAddInjectionInner(`0,System.Object)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBaseCodeContractCheck`1.RemoveInjectionInner(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1">
            <summary>
            Контейнер инъекций, использующий словарь для хранения.
            Требуется внешний контроль для исключения ситуаций одновременного чтения и записи.
            Может использоваться в однопоточных сценариях, либо в многопоточных с вызовом Freeze после занесения всех данных.
            </summary>
            <typeparam name="TKey">Ключ разрешения инъекций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.#ctor(System.Boolean)">
            <summary>
            Конструктор FreezeRequiredGenericInjectionContainer
            </summary>
            <param name="disposeInjectionsWithBuilder">Вызывать ли Dispose у хранимых объектов при уничтожении контейнера</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.#ctor">
            <summary>
            Конструктор FreezeRequiredGenericInjectionContainer
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.IsGoodInjectionForKey(`0,System.Object)">
            <summary>
            Подходит ли данная инъекция для ключа
            </summary>
            <param name="key">Ключ</param>
            <param name="injection">Инъекция</param>
            <returns>Подходит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.TryGetInjectionInner(`0,System.Object@)">
            <summary>
            Внутренний метод попытки извлечь инъекцию
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Полученное значение в случа успеха</param>
            <returns>Удалось ли извлечь</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.ContainsInner(`0)">
            <summary>
            Внутренний метод проверки наличия инъекции
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть ли инъекция в контейнере</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.TryAddInjectionInner(`0,System.Object)">
            <summary>
            Внутренний метод попытки добавить инъекцию в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.AddInjectionInner(`0,System.Object)">
            <summary>
            Внутренний метод добавления инъекции в контейнер
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.RemoveInjectionInner(`0)">
            <summary>
            Внутренний метод удаления инъекции
            </summary>
            <param name="key">Ключ</param>
            <returns>Удалили ли инъекцию</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.GetInjection(`0)">
            <summary>
            Получение инъекции по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Инъекция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.TryGetInjection(`0,System.Object@)">
            <summary>
            Пытается получить инъекцию по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение, если найдено</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.Contains(`0)">
            <summary>
            Содержит ли контейнер инъекцию
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть или нет</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.Core#ServiceClasses#IoC#Injections#IInjectionSource{TKey}#GetInjection(`0)">
            <summary>
            Получение инъекции по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Инъекция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.Core#ServiceClasses#IoC#Injections#IInjectionSource{TKey}#TryGetInjection(`0,System.Object@)">
            <summary>
            Пытается получить инъекцию по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Значение, если найдено</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.Core#ServiceClasses#IoC#Injections#IInjectionSource{TKey}#Contains(`0)">
            <summary>
            Содержит ли контейнер инъекцию
            </summary>
            <param name="key">Ключ</param>
            <returns>Есть или нет</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.FreezeRequiredGenericInjectionContainer`1.Dispose(System.Boolean)">
            <summary>
            Внутреннее освобождение ресурсов
            </summary>
            <param name="isUserCall">True - вызвано пользователем, False - вызвано деструктором</param>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer">
            <summary>
            Контейнер инъекций для хранения соответствия Типа и объекта этого типа.
            Подходит для однопоточных сценариев, а также для многопоточных в случае заморозки.
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.#ctor">
            <summary>
            Конструктор TypeStrictFreezeRequiredInjectionContainer
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.#ctor(System.Boolean)">
            <summary>
            Конструктор TypeStrictFreezeRequiredInjectionContainer
            </summary>
            <param name="disposeInjectionsWithBuilder">Вызывать ли Dispose у хранимых объектов при уничтожении контейнера</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.IsGoodInjectionForKey(System.Type,System.Object)">
            <summary>
            Подходит ли данная инъекция для ключа
            </summary>
            <param name="key">Ключ</param>
            <param name="injection">Инъекция</param>
            <returns>Подходит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.GetInjection``1">
            <summary>
            Получение инъекции по её типу
            </summary>
            <typeparam name="T">Тип запрашиваемой инъекции</typeparam>
            <returns>Инъекция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.TryGetInjection``1(``0@)">
            <summary>
            Попытка получить инъекцию
            </summary>
            <typeparam name="T">Тип запрашиваемой инъекции</typeparam>
            <param name="val">Значение инъекции в случае успеха</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.Contains``1">
            <summary>
            Содержит ли контейнер инъекцию с типом T
            </summary>
            <typeparam name="T">Тип инъекции</typeparam>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.AddInjection``1(``0)">
            <summary>
            Добавить инъекцию в контейнер
            </summary>
            <typeparam name="T">Тип инъекции</typeparam>
            <param name="val">Значение инъекции</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.TryAddInjection``1(``0)">
            <summary>
            Попытаться добавить инъекцию в контейнер
            </summary>
            <typeparam name="T">Тип инъекции</typeparam>
            <param name="val">Значение</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.RemoveInjection``1">
            <summary>
            Удалить инъекцию из контейнера
            </summary>
            <typeparam name="T">Тип удаляемой инъекции</typeparam>
            <returns>Была ли она там</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.GetDirectInjectionResolver">
            <summary>
            Возвращает простой резолвер инъекций
            </summary>
            <returns>Резолвер</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.TypeStrictDirectInjectionResolver">
            <summary>
            Простой резолвер инъекций, опирающийся лишь на тип запрашиваемого объекта
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.TypeStrictDirectInjectionResolver.#ctor(Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer)">
            <summary>
            Конструктор TypeStrictDirectInjectionResolver
            </summary>
            <param name="container">Контейнер, которому он принадлежит</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.TypeStrictDirectInjectionResolver.Resolve(System.Type,System.String,System.Type,System.Object)">
            <summary>
            Разрешить зависимость на основе подробной информации
            </summary>
            <param name="reqObjectType">Тип объекта, который требуется вернуть</param>
            <param name="paramName">Имя параметра, для которого разрешается зависимость (если применимо)</param>
            <param name="forType">Тип, для которого разрешается зависимость (если применимо)</param>
            <param name="extData">Расширенные данные для разрешения зависимости (если есть)</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictFreezeRequiredInjectionContainer.TypeStrictDirectInjectionResolver.Resolve``1(System.Type)">
            <summary>
            Упрощённое разрешение зависимости
            </summary>
            <typeparam name="T">Тип объекта, который требуется вернуть</typeparam>
            <param name="forType">Тип, для которого разрешается зависимость</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer">
            <summary>
            Контейнер инъекций для хранения соответствия Типа и объекта этого типа.
            Является потокобезопасным.
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.#ctor(System.Boolean)">
            <summary>
            Конструктор TypeStrictInjectionContainer
            </summary>
            <param name="disposeInjectionsWithBuilder">Вызывать ли Dispose у хранимых объектов при уничтожении контейнера</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.#ctor">
            <summary>
            Конструктор TypeStrictInjectionContainer
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.IsGoodInjectionForKey(System.Type,System.Object)">
            <summary>
            Подходит ли данная инъекция для ключа
            </summary>
            <param name="key">Ключ</param>
            <param name="injection">Инъекция</param>
            <returns>Подходит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.GetInjection``1">
            <summary>
            Получение инъекции по её типу
            </summary>
            <typeparam name="T">Тип запрашиваемой инъекции</typeparam>
            <returns>Инъекция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.TryGetInjection``1(``0@)">
            <summary>
            Попытка получить инъекцию
            </summary>
            <typeparam name="T">Тип запрашиваемой инъекции</typeparam>
            <param name="val">Значение инъекции в случае успеха</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.Contains``1">
            <summary>
            Содержит ли контейнер инъекцию с типом T
            </summary>
            <typeparam name="T">Тип инъекции</typeparam>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.AddInjection``1(``0)">
            <summary>
            Добавить инъекцию в контейнер
            </summary>
            <typeparam name="T">Тип инъекции</typeparam>
            <param name="val">Значение инъекции</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.TryAddInjection``1(``0)">
            <summary>
            Попытаться добавить инъекцию в контейнер
            </summary>
            <typeparam name="T">Тип инъекции</typeparam>
            <param name="val">Значение</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.RemoveInjection``1">
            <summary>
            Удалить инъекцию из контейнера
            </summary>
            <typeparam name="T">Тип удаляемой инъекции</typeparam>
            <returns>Была ли она там</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.GetDirectInjectionResolver">
            <summary>
            Возвращает простой резолвер инъекций
            </summary>
            <returns>Резолвер</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.TypeStrictDirectInjectionResolver">
            <summary>
            Простой резолвер инъекций, опирающийся лишь на тип запрашиваемого объекта
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.TypeStrictDirectInjectionResolver.#ctor(Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer)">
            <summary>
            Конструктор TypeStrictDirectInjectionResolver
            </summary>
            <param name="container">Контейнер, которому он принадлежит</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.TypeStrictDirectInjectionResolver.Resolve(System.Type,System.String,System.Type,System.Object)">
            <summary>
            Разрешить зависимость на основе подробной информации
            </summary>
            <param name="reqObjectType">Тип объекта, который требуется вернуть</param>
            <param name="paramName">Имя параметра, для которого разрешается зависимость (если применимо)</param>
            <param name="forType">Тип, для которого разрешается зависимость (если применимо)</param>
            <param name="extData">Расширенные данные для разрешения зависимости (если есть)</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionContainer.TypeStrictDirectInjectionResolver.Resolve``1(System.Type)">
            <summary>
            Упрощённое разрешение зависимости
            </summary>
            <typeparam name="T">Тип объекта, который требуется вернуть</typeparam>
            <param name="forType">Тип, для которого разрешается зависимость</param>
            <returns>Найденный объект запрашиваемого типа</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionExtension">
            <summary>
            Расширения для контейнеров инъекций с ключём Type
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionExtension.GetInjection``1(Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase{System.Type})">
            <summary>
            Получение инъекции по её типу
            </summary>
            <typeparam name="T">Тип запрашиваемой инъекции</typeparam>
            <param name="obj">Контейнер</param>
            <returns>Инъекция</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionExtension.TryGetInjection``1(Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase{System.Type},``0@)">
            <summary>
            Попытка получить инъекцию
            </summary>
            <typeparam name="T">Тип запрашиваемой инъекции</typeparam>
            <param name="obj">Контейнер</param>
            <param name="val">Значение инъекции в случае успеха</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionExtension.Contains``1(Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase{System.Type})">
            <summary>
            Содержит ли контейнер инъекцию с типом T
            </summary>
            <typeparam name="T">Тип инъекции</typeparam>
            <param name="obj">Контейнер</param>
            <returns>Содержит ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionExtension.AddInjection``1(Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase{System.Type},``0)">
            <summary>
            Добавить инъекцию в контейнер
            </summary>
            <typeparam name="T">Тип инъекции</typeparam>
            <param name="obj">Контейнер</param>
            <param name="val">Значение инъекции</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionExtension.TryAddInjection``1(Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase{System.Type},``0)">
            <summary>
            Попытаться добавить инъекцию в контейнер
            </summary>
            <typeparam name="T">Тип инъекции</typeparam>
            <param name="obj">Контейнер</param>
            <param name="val">Значение</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Injections.TypeStrictInjectionExtension.RemoveInjection``1(Core.ServiceClasses.IoC.Injections.GenericInjectionContainerBase{System.Type})">
            <summary>
            Удалить инъекцию из контейнера
            </summary>
            <typeparam name="T">Тип удаляемой инъекции</typeparam>
            <param name="obj">Контейнер</param>
            <returns>Была ли она там</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.IObjectLocatorCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.IObjectLocatorCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.DeferedSingletonLifetime">
            <summary>
            Контейнер для синглтона с отложенным созданием объекта
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.LifetimeBase">
            <summary>
            Контейнер объекта, управляющий временем его жизни
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.LifetimeBase.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.LifetimeBase.#ctor(System.Type)">
            <summary>
            Конструктор LifetimeBase
            </summary>
            <param name="outType">Тип объекта, возвращаемый данным контейнером</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.LifetimeBase.GetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Возвращает объект, которым управляет данный контейнер
            </summary>
            <param name="resolver">Резолвер инъекций</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.LifetimeBase.TryGetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object@)">
            <summary>
            Пытается вернуть объект, которым управляет данный контейнер.
            Ошибки могут происходить в случае, если нет требуемых инъекций для создания
            </summary>
            <param name="resolver">Резолвер инъекций</param>
            <param name="val">Полученный объект (в случае успеха)</param>
            <returns>Удалось ли получить объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.LifetimeBase.Dispose(System.Boolean)">
            <summary>
            Внутренний метод освобождения ресурсов
            </summary>
            <param name="isUserCall">Был ли вызван пользователем (false - вызван деструктором)</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.LifetimeBase.Dispose">
            <summary>
            Освобождение ресурсов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.Lifetime.LifetimeBase.OutputType">
            <summary>
            Тип возвращаемого объекта
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.DeferedSingletonLifetime.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.DeferedSingletonLifetime.#ctor(System.Func{Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object},System.Type)">
            <summary>
            Конструктор DeferedSingletonLifetime
            </summary>
            <param name="createInstanceFunc">Функция создания объекта</param>
            <param name="objType">Тип создаваемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.DeferedSingletonLifetime.GetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Возвращает объект, которым управляет данный контейнер
            </summary>
            <param name="resolver">Резолвер инъекций</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.DeferedSingletonLifetime.Dispose(System.Boolean)">
            <summary>
            Внутренний метод освобождения ресурсов
            </summary>
            <param name="isUserCall">Был ли вызван пользователем (false - вызван деструктором)</param>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory">
            <summary>
            Базовый класс для фабрики создания объектов управления временем жизни
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactory.Create(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создание объекта управления временем жизни
            </summary>
            <param name="objType">Тип хранимого объекта</param>
            <param name="injection">Резолвер инъекций</param>
            <param name="extInfo">Расширенная информация (если есть)</param>
            <returns>Объект управления жизнью объекта</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.Factories.SingletonLifetimeFactory">
            <summary>
            Фабрика для синглтона (SingletonLifetime)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.Factories.SingletonLifetimeFactory.Create(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создание объекта управления временем жизни
            </summary>
            <param name="objType">Тип хранимого объекта</param>
            <param name="injection">Резолвер инъекций</param>
            <param name="extInfo">Расширенная информация (если есть)</param>
            <returns>Объект управления жизнью объекта</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.Factories.DeferedSingletonLifetimeFactory">
            <summary>
            Фабрика для синглтона с отложенной инициализацией (DeferedSingletonLifetime)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.Factories.DeferedSingletonLifetimeFactory.Create(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создание объекта управления временем жизни
            </summary>
            <param name="objType">Тип хранимого объекта</param>
            <param name="injection">Резолвер инъекций</param>
            <param name="extInfo">Расширенная информация (если есть)</param>
            <returns>Объект управления жизнью объекта</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.Factories.PerThreadLifetimeFactory">
            <summary>
            Фабрика для PerThreadLifetime
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.Factories.PerThreadLifetimeFactory.Create(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создание объекта управления временем жизни
            </summary>
            <param name="objType">Тип хранимого объекта</param>
            <param name="injection">Резолвер инъекций</param>
            <param name="extInfo">Расширенная информация (если есть)</param>
            <returns>Объект управления жизнью объекта</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.Factories.PerCallLifetimeFactory">
            <summary>
            Фабрика для PerCallInterfaceLifetime
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.Factories.PerCallLifetimeFactory.Create(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создание объекта управления временем жизни
            </summary>
            <param name="objType">Тип хранимого объекта</param>
            <param name="injection">Резолвер инъекций</param>
            <param name="extInfo">Расширенная информация (если есть)</param>
            <returns>Объект управления жизнью объекта</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.Factories.PerCallInlinedParamsLifetimeFactory">
            <summary>
            Фабрика для PerCallInlinedParamsInterfaceLifetime
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.Factories.PerCallInlinedParamsLifetimeFactory.Create(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>
            Создание объекта управления временем жизни
            </summary>
            <param name="objType">Тип хранимого объекта</param>
            <param name="injection">Резолвер инъекций</param>
            <param name="extInfo">Расширенная информация (если есть)</param>
            <returns>Объект управления жизнью объекта</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactoryCodeContractCheck">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactoryCodeContractCheck.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.Factories.LifetimeFactoryCodeContractCheck.Create(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.LifetimeFactories">
            <summary>
            Фабрики для создания контейнеров, управляющих объектами
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.LifetimeFactories.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.LifetimeFactories.GetLifetimeFactory(Core.ServiceClasses.IoC.ObjectInstantiationMode)">
            <summary>
            Получение фабрики по режиму инстанцирования объекта
            </summary>
            <param name="instMode">Режим инстанцирования</param>
            <returns>Фабрика</returns>
        </member>
        <member name="P:Core.ServiceClasses.IoC.LifetimeFactories.Singleton">
            <summary>
            Фабрика для синглтона
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.LifetimeFactories.DeferedSingleton">
            <summary>
            Фабрика для синглтона с отложенной инициализацией
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.LifetimeFactories.PerThread">
            <summary>
            Фабрика для контейнера хранения объекта на каждый поток
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.LifetimeFactories.PerCall">
            <summary>
            Фабрика для контейнера, который создаёт объект на каждый вызов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.LifetimeFactories.PerCallInlinedParams">
            <summary>
            Фабрика для контейнера, который создаёт объект на каждый вызов с зашитыми параметрами
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.PerCallInlinedParamsInterfaceLifetime">
            <summary>
            Контейнер для создания нового объекта при каждом вызове. 
            Параметры зашиты и не выбираются каждый раз из резолвера инъекций
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerCallInlinedParamsInterfaceLifetime.#ctor(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreatorNoParam)">
            <summary>
            Конструктор PerCallInlinedParamsInterfaceLifetime
            </summary>
            <param name="outType">Тип созаваемого объекта</param>
            <param name="createInstObj">Интерфейс, который умеет создавать объект</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerCallInlinedParamsInterfaceLifetime.GetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Возвращает объект, которым управляет данный контейнер
            </summary>
            <param name="resolver">Резолвер инъекций</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.PerCallInlinedParamsLifetime">
            <summary>
            Контейнер для создания нового объекта при каждом вызове. 
            Параметры зашиты и не выбираются каждый раз из резолвера инъекций
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerCallInlinedParamsLifetime.#ctor(System.Type,System.Func{System.Object})">
            <summary>
            Конструктор PerCallInlinedParamsLifetime
            </summary>
            <param name="outType">Тип созаваемого объекта</param>
            <param name="createInstanceFunc">Функция создания нового объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerCallInlinedParamsLifetime.GetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Возвращает объект, которым управляет данный контейнер
            </summary>
            <param name="resolver">Резолвер инъекций</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.PerCallInterfaceLifetime">
            <summary>
            Контейнер для создания нового объекта при каждом вызове
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerCallInterfaceLifetime.#ctor(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreator)">
            <summary>
            Конструктор PerCallInterfaceLifetime
            </summary>
            <param name="outType">Тип созаваемого объекта</param>
            <param name="createInstanceObj">Интерфейс, который умеет создавать объект</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerCallInterfaceLifetime.GetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Возвращает объект, которым управляет данный контейнер
            </summary>
            <param name="resolver">Резолвер инъекций</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.PerCallLifetime">
            <summary>
            Контейнер для создания нового объекта при каждом вызове
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerCallLifetime.#ctor(System.Type,System.Func{Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object})">
            <summary>
            Конструктор PerCallLifetime
            </summary>
            <param name="outType">Тип созаваемого объекта</param>
            <param name="createInstanceFunc">Функция создания нового объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerCallLifetime.GetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Возвращает объект, которым управляет данный контейнер
            </summary>
            <param name="resolver">Резолвер инъекций</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.PerThreadLifetime">
            <summary>
            Контейнер для хранения копии объекта на каждый поток
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerThreadLifetime.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerThreadLifetime.#ctor(System.Func{Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver,System.Object},System.Type)">
            <summary>
            Конструктор PerThreadLifetime
            </summary>
            <param name="createInstFunc">Функция создания нового объекта</param>
            <param name="objType">Тип созаваемого объекта</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerThreadLifetime.GetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Возвращает объект, которым управляет данный контейнер
            </summary>
            <param name="resolver">Резолвер инъекций</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.PerThreadLifetime.Dispose(System.Boolean)">
            <summary>
            Внутренний метод освобождения ресурсов
            </summary>
            <param name="isUserCall">Был ли вызван пользователем (false - вызван деструктором)</param>
        </member>
        <member name="T:Core.ServiceClasses.IoC.ObjectLocator`4">
            <summary>
            Шаблонный класс локатора объектов для упрощения жизни
            </summary>
            <typeparam name="TInjection">Тип контейнера инъекций</typeparam>
            <typeparam name="TInjKey">Тип ключа инъекций</typeparam>
            <typeparam name="TAssociation">Тип контейнера ассоциаций</typeparam>
            <typeparam name="TAssocKey">Тип ключа ассоциаций</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.#ctor(`0,`2,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Конструктор ObjectLocator принимающий все необходимые объекты
            </summary>
            <param name="injection">Контейнер инъекций</param>
            <param name="association">Контейнер ассоциаций</param>
            <param name="resolver">Резолвер инъекций</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.#ctor">
            <summary>
            Конструктор ObjectLocator без параметров.
            С ним обязателен вызов SetInnerObjects
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.SetInnerObjects(`0,`2,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Установка значений всех необходимых объектов
            </summary>
            <param name="injection">Контейнер инъекций</param>
            <param name="association">Контейнер ассоциаций</param>
            <param name="resolver">Резолвер инъекций</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.Resolve(`3)">
            <summary>
            Получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.TryResolve(`3,System.Object@)">
            <summary>
            Попытаться получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.CanResolve(`3)">
            <summary>
            Можно ли получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Можно ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.Core#ServiceClasses#IoC#IObjectLocator{TAssocKey}#Resolve(`3)">
            <summary>
            Получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.Core#ServiceClasses#IoC#IObjectLocator{TAssocKey}#TryResolve(`3,System.Object@)">
            <summary>
            Попытаться получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <param name="val">Объект, если удалось получить</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.Core#ServiceClasses#IoC#IObjectLocator{TAssocKey}#CanResolve(`3)">
            <summary>
            Можно ли получить объект по ключу
            </summary>
            <param name="key">Ключ</param>
            <returns>Можно ли</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.Dispose(System.Boolean)">
            <summary>
            Внутреннее освобождение ресурсов
            </summary>
            <param name="isUserCall">True - вызвано пользователем, False - вызвано деструктором</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ObjectLocator`4.Dispose">
            <summary>
            Освобождение ресурсов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.ObjectLocator`4.Injection">
            <summary>
            Контейнер инъекций
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.IoC.ObjectLocator`4.Association">
            <summary>
            Контейнер ассоциаций
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolverCodeContractCheck">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolverCodeContractCheck.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolverCodeContractCheck.Resolve(System.Type,System.String,System.Type,System.Object)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolverCodeContractCheck.Resolve``1(System.Type)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.LifetimeBaseCodeContractCheck">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.LifetimeBaseCodeContractCheck.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.LifetimeBaseCodeContractCheck.GetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.Lifetime.SingletonLifetime">
            <summary>
            Контейнер для синглтона
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.SingletonLifetime.#ctor(System.Object)">
            <summary>
            Конструктор SingletonLifetime
            </summary>
            <param name="obj">Объект, который будет хранится в контейнере</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.SingletonLifetime.#ctor(System.Object,System.Boolean)">
            <summary>
            Конструктор SingletonLifetime
            </summary>
            <param name="obj">Объект, который будет хранится в контейнере</param>
            <param name="disposeInnerObject">Вызывать ли Dispose у хранимого объекта при уничтожении контейнера</param>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.SingletonLifetime.GetInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Возвращает объект, которым управляет данный контейнер
            </summary>
            <param name="resolver">Резолвер инъекций</param>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.SingletonLifetime.GetInstance">
            <summary>
            Возвращает объект, которым управляет данный контейнер
            </summary>
            <returns>Полученный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.Lifetime.SingletonLifetime.Dispose(System.Boolean)">
            <summary>
            Внутренний метод освобождения ресурсов
            </summary>
            <param name="isUserCall">Был ли вызван пользователем (false - вызван деструктором)</param>
        </member>
        <member name="T:Core.ServiceClasses.IoC.LocatorTargetObjectAttribute">
            <summary>
            Базовый аттрибут, который используется при автоматическом поиске соответствий
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.LocatorTargetObjectAttribute.#ctor(Core.ServiceClasses.IoC.ObjectInstantiationMode)">
            <summary>
            Конструктор LocatorTargetObjectAttribute
            </summary>
            <param name="mode">Режим инстанцирования объекта</param>
        </member>
        <member name="P:Core.ServiceClasses.IoC.LocatorTargetObjectAttribute.Mode">
            <summary>
            Режим инстанцирования объекта
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreator">
            <summary>
            Интерфейс для объекта, который выполняет создание конкретного объекта
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreator.CreateInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Создаёт объект
            </summary>
            <param name="resolver">Резолвер зависимостей</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreatorNoParam">
            <summary>
            Интерфейс для объекта, который выполняет создание конкретного объекта
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreatorNoParam.CreateInstance">
            <summary>
            Создаёт объект
            </summary>
            <returns>Созданный объект</returns>
        </member>
        <member name="T:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreatorCodeContractCheck">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreatorCodeContractCheck.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreatorCodeContractCheck.CreateInstance(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreatorNoParamCodeContractCheck">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreatorNoParamCodeContractCheck.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.IInstanceCreatorNoParamCodeContractCheck.CreateInstance">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.IoC.ServiceStuff.InstantiationService">
            <summary>
            Вспомогательные методы для поддержки создания объектов
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.InstantiationService.CreateObject(System.Type)">
            <summary>
            Создать объект типа objType.
            Должен существовать конструктор без параметров
            </summary>
            <param name="objType">Тип объекта</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.InstantiationService.CreateObject``1(Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Создать объект типа T
            </summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="resolver">Источник инъекций</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.IoC.ServiceStuff.InstantiationService.CreateObject(System.Type,Core.ServiceClasses.IoC.ServiceStuff.IInjectionResolver)">
            <summary>
            Создать объект типа objType
            </summary>
            <param name="objType">Тип объекта</param>
            <param name="resolver">Источник инъекций</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="T:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2">
            <summary>
            Пул с балансировкой изменением числа элементов при необходимости
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
            <typeparam name="PE">Тип обёртки над элементом</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.Pool.PoolManagerBase`2">
            <summary>
            Базовый класс для пулов
            </summary>
            <typeparam name="T">Тип элемента пула</typeparam>
            <typeparam name="PE">Тип обёртки для элемента пула</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Rent">
            <summary>
            Арендовать элемент
            </summary>
            <returns>Обёртка над элементом пула</returns>
            <exception cref="T:Core.ServiceClasses.CantRetrieveElementException">Если не удалось получить элемент</exception>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Rent(System.Boolean)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="throwOnUnavail">Выбрасывать исключение при недоступности элемента</param>
            <returns>Обёртка над элементом пула</returns>
            <exception cref="T:Core.ServiceClasses.CantRetrieveElementException">Если не удалось получить элемент и throwOnUnavail == true</exception>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Rent(System.Threading.CancellationToken)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="token">Токен для отмены</param>
            <returns>Обёртка над элементом пула</returns>
            <exception cref="T:Core.ServiceClasses.CantRetrieveElementException">Если не удалось получить элемент</exception>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Rent(System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="token">Токен для отмены</param>
            <param name="throwOnUnavail">Выбрасывать исключение при недоступности элемента</param>
            <returns>Обёртка над элементом пула</returns>
            <exception cref="T:Core.ServiceClasses.CantRetrieveElementException">Если не удалось получить элемент и throwOnUnavail == true</exception>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Rent(System.Int32)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="timeout">Таймаут</param>
            <returns>Обёртка над элементом пула</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Rent(System.Int32,System.Boolean)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="timeout">Таймаут</param>
            <param name="throwOnUnavail">Выбрасывать исключение при недоступности элемента</param>
            <returns>Обёртка над элементом пула</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Rent(System.Int32,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="timeout">Таймаут (-1 - бесконечно, 0 - быстрая проверка, &gt; 0 - полная проверка)</param>
            <param name="token">Токен для отмены</param>
            <param name="throwOnUnavail">Выбрасывать исключение при недоступности элемента</param>
            <returns>Обёртка над элементом пула</returns>
            <exception cref="T:Core.ServiceClasses.CantRetrieveElementException">Если не удалось получить элемент и throwOnUnavail == true</exception>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBase`2.Dispose">
            <summary>
            Освобождение ресурсов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.PoolManagerBase`2.ElementCount">
            <summary>
            Общее число элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.PoolManagerBase`2.FreeElementCount">
            <summary>
            Число свободных в данный момент элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.PoolManagerBase`2.RentedElementCount">
            <summary>
            Число арендованных элементов в данный момент
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.IPoolElementReleaser`1">
            <summary>
            Интерфейс для выполнения освобождения занятого элемента пула
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.IPoolElementReleaser`1.Release(`0)">
            <summary>
            Выполнить освобождение
            </summary>
            <param name="elem">Элемент пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2._elementList">
            <summary>
            Список всех элементов
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2._freeElements">
            <summary>
            Коллекция свободных элементов
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.#ctor(System.Int32,System.Int32,System.Int32,System.Collections.Generic.IComparer{`0},System.String)">
            <summary>
            Конструктор BalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.#ctor(System.Int32,System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Конструктор BalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0},System.String)">
            <summary>
            Конструктор BalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.#ctor(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Конструктор BalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор BalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0},System.String)">
            <summary>
            Конструктор BalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.#ctor(System.Int32,System.String)">
            <summary>
            Конструктор BalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Конструктор BalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.#ctor(System.Int32)">
            <summary>
            Конструктор BalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.CreateElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Создание элемента. Ожидание крайне не желательно. 
            Не должен кидать исключения, если только не надо прибить всю систему.
            </summary>
            <param name="elem">Созданный элемент, если удалось создать</param>
            <param name="timeout">Таймаут создания</param>
            <param name="token">Токен отмены создания элемента</param>
            <returns>Удалось ли создать элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.IsValidElement(`0)">
            <summary>
            Проверка, пригоден ли элемент для дальнейшего использования
            </summary>
            <param name="elem">Элемент</param>
            <returns>Пригоден ли для дальнейшего использования</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.DestroyElement(`0)">
            <summary>
            Уничтожить элемент
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.IsBetterAllocateNew(`0)">
            <summary>
            Проверяет, не лучше ли выделить новый элемент в пуле вместо использования указанного
            </summary>
            <param name="elem">Элемент</param>
            <returns>Лучше ли выделить новый</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.CreatePoolElement(`0)">
            <summary>
            Создание обёртки над элементом.
            </summary>
            <param name="elem">Элемент</param>
            <returns>Обёртка</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.GetTimeMeasureInMs">
            <summary>
            Получить отсчёт времени в миллисекундах
            </summary>
            <returns>Текущее значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.ElementWaitingCancellationNotification">
            <summary>
            Обработчик нотификации об отмене ожидания элементов
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.TryTakeBestElementFromFreeList(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Попытаться достать лучший на данный момент элемент
            </summary>
            <param name="result">Найденный элемент</param>
            <param name="timeout">Таймаут извлечения</param>
            <param name="token">Токен отмены</param>
            <returns>Удалось ли найти свободный элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.TryTakeBestElementFromFreeList(`0@)">
            <summary>
            Попытаться достать лучший на данный момент элемент
            </summary>
            <param name="result">Найденный элемент</param>
            <returns>Удалось ли найти свободный элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.AddBackToFreeList(`0)">
            <summary>
            Вернуть элемент в коллекцию свободных
            </summary>
            <param name="element">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.FillPoolUpTo(System.Int32)">
            <summary>
            Наполнить пул до count элементов
            </summary>
            <param name="count">Число элементов, до которого наполняется пул</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.InitNewElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Инициализация нового элемента в пуле
            </summary>
            <param name="elem">Инициализированный элемент</param>
            <param name="timeout">Таймаут инициализации</param>
            <param name="token">Токен отмены инициализации</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.RemoveElement(`0)">
            <summary>
            Удаление элемента из пула
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.TryGetElementInfiniteTimeout(`0@,System.Threading.CancellationToken)">
            <summary>
            Получение элемента при аренде
            </summary>
            <param name="result">Извлечённый элемент</param>
            <param name="token">Токен для отмены ожидания</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.TryGetElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Получение элемента при аренде с таймаутом
            </summary>
            <param name="result">Извлечённый элемент</param>
            <param name="timeout">Таймаут</param>
            <param name="token">Токен для отмены</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.Rent(System.Int32,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="timeout">Таймаут (-1 - бесконечно, 0 - быстрая проверка, &gt; 0 - полная проверка)</param>
            <param name="token">Токен для отмены</param>
            <param name="throwOnUnavail">Выбрасывать исключение при недоступности элемента</param>
            <returns>Обёртка над элементом пула</returns>
            <exception cref="T:Core.ServiceClasses.CantRetrieveElementException">Если не удалось получить элемент и throwOnUnavail == true</exception>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.Core#ServiceClasses#Pool#IPoolElementReleaser{T}#Release(`0)">
            <summary>
            Освобождение элемента пула и добавление его к свободным
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="P:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.PoolName">
            <summary>
            Имя пула
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.ElementCount">
            <summary>
            Общее число элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.FreeElementCount">
            <summary>
            Число свободных в данный момент элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.MaxElementCount">
            <summary>
            Максимально возможное число элементов в пуле
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManager`2.RentedElementCount">
            <summary>
            Число арендованных элементов в данный момент
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManagerCodeContractCheck`2">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManagerCodeContractCheck`2.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManagerCodeContractCheck`2.CreateElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManagerCodeContractCheck`2.IsValidElement(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManagerCodeContractCheck`2.DestroyElement(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingDynamicSizePoolManagerCodeContractCheck`2.CreatePoolElement(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1">
            <summary>
            Пул с ручным заполнением элементами и балансировкой
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.#ctor(System.Collections.Generic.IComparer{`0},System.String,System.Boolean)">
            <summary>
            Конструктор BalancingStaticPoolManager
            </summary>
            <param name="elementComparer">Объект сравнения элементов с целью поиска наилучшего</param>
            <param name="name">Имя пула</param>
            <param name="disposeElementOnDestroy">Вызывать ли Dispose у элементов при их уничтожении</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.#ctor(System.Collections.Generic.IComparer{`0},System.String)">
            <summary>
            Конструктор BalancingStaticPoolManager
            </summary>
            <param name="elementComparer">Объект сравнения элементов с целью поиска наилучшего</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.#ctor">
            <summary>
            Конструктор BalancingStaticPoolManager
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.GetTimeMeasureInMs">
            <summary>
            Получить отсчёт времени в миллисекундах
            </summary>
            <returns>Текущее значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.ElementWaitingCancellationNotification">
            <summary>
            Обработчик нотификации об отмене ожидания элементов
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.TryTakeBestElementFromFreeList(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Попытаться достать лучший на данный момент элемент
            </summary>
            <param name="result">Найденный элемент</param>
            <param name="timeout">Таймаут извлечения</param>
            <param name="token">Токен отмены</param>
            <returns>Удалось ли найти свободный элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.TryTakeBestElementFromFreeList(`0@)">
            <summary>
            Попытаться достать лучший на данный момент элемент
            </summary>
            <param name="result">Найденный элемент</param>
            <returns>Удалось ли найти свободный элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.AddBackToFreeList(`0)">
            <summary>
            Вернуть элемент в коллекцию свободных
            </summary>
            <param name="element">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.AddNewElement(`0)">
            <summary>
            Добавление нового элемента в пул
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.DestroyElement(`0)">
            <summary>
            Освобождение ресурсов элемента (точка расширения)
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.DestroyElementInner(`0)">
            <summary>
            Освобождение ресурсов элемента
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.RemoveElementInner(`0)">
            <summary>
            Удаление элемента из пула
            </summary>
            <param name="elem">Элемент</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.RemoveAndDestroyElementInner(`0)">
            <summary>
            Удалить и освободить ресурсы элемента
            </summary>
            <param name="elem">Элемент</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.RemoveElement(Core.ServiceClasses.Pool.PoolElement{`0},System.Boolean)">
            <summary>
            Удаление арендованного элемента из пула (напрмер, если стал не валиден)
            </summary>
            <param name="elemWrapper">Обёртка над элементом</param>
            <param name="disposeIfValid">Освободить ресурсы элемента</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.RemoveElement(Core.ServiceClasses.Pool.PoolElement{`0})">
            <summary>
            Удаление арендованного элемента из пула (напрмер, если стал не валиден)
            </summary>
            <param name="elemWrapper">Обёртка над элементом</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.Rent(System.Int32,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="timeout">Таймаут (-1 - бесконечно, 0 - быстрая проверка, &gt; 0 - полная проверка)</param>
            <param name="token">Токен для отмены</param>
            <param name="throwOnUnavail">Выбрасывать исключение при недоступности элемента</param>
            <returns>Обёртка над элементом пула</returns>
            <exception cref="T:Core.ServiceClasses.CantRetrieveElementException">Если не удалось получить элемент и throwOnUnavail == true</exception>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.Core#ServiceClasses#Pool#IPoolElementReleaser{T}#Release(`0)">
            <summary>
            Освобождение элемента пула и добавление его к свободным
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="P:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.PoolName">
            <summary>
            Имя пула
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.ElementCount">
            <summary>
            Общее число элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.FreeElementCount">
            <summary>
            Число свободных в данный момент элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.BalancingStaticPoolManager`1.RentedElementCount">
            <summary>
            Число арендованных элементов в данный момент
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.DynamicSizePoolManager`2">
            <summary>
            Пул с изменением числа элементов при необходимости
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
            <typeparam name="PE">Тип обёртки над элементом</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.Pool.DynamicSizePoolManager`2._elementList">
            <summary>
            Список всех элементов
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.Pool.DynamicSizePoolManager`2._freeElements">
            <summary>
            Коллекция свободных элементов
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор DynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Конструктор DynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор DynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор DynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.#ctor(System.Int32,System.String)">
            <summary>
            Конструктор DynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.#ctor(System.Int32)">
            <summary>
            Конструктор DynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.CreateElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Создание элемента. Ожидание крайне не желательно. 
            Не должен кидать исключения, если только не надо прибить всю систему.
            </summary>
            <param name="elem">Созданный элемент, если удалось создать</param>
            <param name="timeout">Таймаут создания</param>
            <param name="token">Токен отмены создания элемента</param>
            <returns>Удалось ли создать элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.IsValidElement(`0)">
            <summary>
            Проверка, пригоден ли элемент для дальнейшего использования
            </summary>
            <param name="elem">Элемент</param>
            <returns>Пригоден ли для дальнейшего использования</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.DestroyElement(`0)">
            <summary>
            Уничтожить элемент
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.CreatePoolElement(`0)">
            <summary>
            Создание обёртки над элементом.
            </summary>
            <param name="elem">Элемент</param>
            <returns>Обёртка</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.GetTimeMeasureInMs">
            <summary>
            Получить отсчёт времени в миллисекундах
            </summary>
            <returns>Текущее значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.FillPoolUpTo(System.Int32)">
            <summary>
            Наполнить пул до count элементов
            </summary>
            <param name="count">Число элементов, до которого наполняется пул</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.InitNewElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Инициализация нового элемента в пуле
            </summary>
            <param name="elem">Инициализированный элемент</param>
            <param name="timeout">Таймаут инициализации</param>
            <param name="token">Токен отмены инициализации</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.RemoveElement(`0)">
            <summary>
            Удаление элемента из пула
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.TryGetElementInfiniteTimeout(`0@,System.Threading.CancellationToken)">
            <summary>
            Получение элемента при аренде
            </summary>
            <param name="result">Извлечённый элемент</param>
            <param name="token">Токен для отмены ожидания</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.TryGetElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Получение элемента при аренде с таймаутом
            </summary>
            <param name="result">Извлечённый элемент</param>
            <param name="timeout">Таймаут</param>
            <param name="token">Токен для отмены</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.Rent(System.Int32,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="timeout">Таймаут (-1 - бесконечно, 0 - быстрая проверка, &gt; 0 - полная проверка)</param>
            <param name="token">Токен для отмены</param>
            <param name="throwOnUnavail">Выбрасывать исключение при недоступности элемента</param>
            <returns>Обёртка над элементом пула</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:Core.ServiceClasses.CantRetrieveElementException">Если не удалось получить элемент и throwOnUnavail == true</exception>
            <exception cref="T:System.TimeoutException">Если не удалось получить элемент и throwOnUnavail == true</exception>
            <exception cref="T:System.OperationCanceledException">Если не удалось получить элемент и throwOnUnavail == true</exception>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.Core#ServiceClasses#Pool#IPoolElementReleaser{T}#Release(`0)">
            <summary>
            Освобождение элемента пула и добавление его к свободным
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="P:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.PoolName">
            <summary>
            Имя пула
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.ElementCount">
            <summary>
            Общее число элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.FreeElementCount">
            <summary>
            Число свободных в данный момент элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.MaxElementCount">
            <summary>
            Максимально возможное число элементов в пуле
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.DynamicSizePoolManager`2.RentedElementCount">
            <summary>
            Число арендованных элементов в данный момент
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.DynamicSizePoolManagerCodeContractCheck`2">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManagerCodeContractCheck`2.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManagerCodeContractCheck`2.CreateElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManagerCodeContractCheck`2.IsValidElement(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManagerCodeContractCheck`2.DestroyElement(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.DynamicSizePoolManagerCodeContractCheck`2.CreatePoolElement(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1">
            <summary>
            Пул с изменением числа элементов при необходимости и выделенной в интрефейс логикой
            </summary>
            <typeparam name="T">Тип элемента пула</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.Pool.UnifiedDynamicSizePoolManager`1">
            <summary>
            Пул с изменением числа элементов при необходимости, а также унифицированной проверкой валидности элементов
            </summary>
            <typeparam name="T">Тип элемента пула</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.Pool.IPoolElementValidator`1">
            <summary>
            Интерфейс проверки валидности объекта (элемента пула)
            </summary>
            <typeparam name="T">Тип элемента пула</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.IPoolElementValidator`1.IsValid(`0)">
            <summary>
            Можно ли использовать данный объект
            </summary>
            <param name="elem">Объект</param>
            <returns>Валиден ли объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedDynamicSizePoolManager`1.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор UnifiedDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedDynamicSizePoolManager`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Конструктор UnifiedDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedDynamicSizePoolManager`1.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор UnifiedDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedDynamicSizePoolManager`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор UnifiedDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedDynamicSizePoolManager`1.#ctor(System.Int32,System.String)">
            <summary>
            Конструктор UnifiedDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedDynamicSizePoolManager`1.#ctor(System.Int32)">
            <summary>
            Конструктор UnifiedDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedDynamicSizePoolManager`1.CreatePoolElement(`0)">
            <summary>
            Создание обёртки над элементом.
            </summary>
            <param name="elem">Элемент</param>
            <returns>Обёртка</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedDynamicSizePoolManager`1.Core#ServiceClasses#Pool#IPoolElementValidator{T}#IsValid(`0)">
            <summary>
            Можно ли использовать данный объект (Реализация интерфейса IPoolElementValidator)
            </summary>
            <param name="elem">Объект</param>
            <returns>Валиден ли объект</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.#ctor(Core.ServiceClasses.Pool.IDynamicSizePoolLogic{`0},System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор InterfaceBasedDynamicSizePoolManager
            </summary>
            <param name="logic">Объект, реализующий логику работы пула</param>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.#ctor(Core.ServiceClasses.Pool.IDynamicSizePoolLogic{`0},System.Int32,System.Int32,System.Int32)">
            <summary>
            Конструктор InterfaceBasedDynamicSizePoolManager
            </summary>
            <param name="logic">Объект, реализующий логику работы пула</param>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.#ctor(Core.ServiceClasses.Pool.IDynamicSizePoolLogic{`0},System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор InterfaceBasedDynamicSizePoolManager
            </summary>
            <param name="logic">Объект, реализующий логику работы пула</param>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.#ctor(Core.ServiceClasses.Pool.IDynamicSizePoolLogic{`0},System.Int32,System.Int32)">
            <summary>
            Конструктор InterfaceBasedDynamicSizePoolManager
            </summary>
            <param name="logic">Объект, реализующий логику работы пула</param>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.#ctor(Core.ServiceClasses.Pool.IDynamicSizePoolLogic{`0},System.Int32,System.String)">
            <summary>
            Конструктор InterfaceBasedDynamicSizePoolManager
            </summary>
            <param name="logic">Объект, реализующий логику работы пула</param>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.#ctor(Core.ServiceClasses.Pool.IDynamicSizePoolLogic{`0},System.Int32)">
            <summary>
            Конструктор InterfaceBasedDynamicSizePoolManager
            </summary>
            <param name="logic">Объект, реализующий логику работы пула</param>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.CreateElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Создание элемента. Ожидание крайне не желательно. 
            Не должен кидать исключения, если только не надо прибить всю систему.
            </summary>
            <param name="elem">Созданный элемент, если удалось создать</param>
            <param name="timeout">Таймаут создания</param>
            <param name="token">Токен отмены создания</param>
            <returns>Удалось ли создать элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.IsValidElement(`0)">
            <summary>
            Проверка, пригоден ли элемент для дальнейшего использования
            </summary>
            <param name="elem">Элемент</param>
            <returns>Пригоден ли для дальнейшего использования</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.InterfaceBasedDynamicSizePoolManager`1.DestroyElement(`0)">
            <summary>
            Уничтожить элемент
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="T:Core.ServiceClasses.Pool.IDynamicSizePoolLogic`1">
            <summary>
            Интерфейс с логикой работы пула
            </summary>
            <typeparam name="T">Тип элемента пула</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.IDynamicSizePoolLogic`1.CreateElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Создание элемента. Ожидание крайне не желательно. 
            Не должен кидать исключения, если только не надо прибить всю систему.
            </summary>
            <param name="elem">Созданный элемент, если удалось создать</param>
            <param name="timeout">Таймаут создания</param>
            <param name="token">Токен отмены создания</param>
            <returns>Удалось ли создать элемент</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.IDynamicSizePoolLogic`1.IsValidElement(`0)">
            <summary>
            Проверка, пригоден ли элемент для дальнейшего использования
            </summary>
            <param name="elem">Элемент</param>
            <returns>Пригоден ли для дальнейшего использования</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.IDynamicSizePoolLogic`1.ReleaseElement(`0)">
            <summary>
            Уничтожить элемент
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="T:Core.ServiceClasses.Pool.IDynamicSizePoolLogicCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.IDynamicSizePoolLogicCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.IDynamicSizePoolLogicCodeContractCheck`1.CreateElement(`0@,System.Int32,System.Threading.CancellationToken)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.IDynamicSizePoolLogicCodeContractCheck`1.IsValidElement(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.IDynamicSizePoolLogicCodeContractCheck`1.ReleaseElement(`0)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.PoolElement`1">
            <summary>
            Базовый класс для обёртки над элементами пула
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolElement`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolElement`1.#ctor(Core.ServiceClasses.Pool.IPoolElementReleaser{`0},`0)">
            <summary>
            Конструктор
            </summary>
            <param name="pool">Менеджер пула, либо другой объект для освобождения элемента</param>
            <param name="elem">Сам элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolElement`1.OnRelease(`0)">
            <summary>
            Вызывается при освобождении данного элемента
            </summary>
            <param name="elem">Освобождаемый элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolElement`1.Dispose(System.Boolean,System.Boolean)">
            <summary>
            Код освобождения элемента
            </summary>
            <param name="isUserCall">Вызвано ли освобождение явно</param>
            <param name="isFreeWrapper">Вызвано из кода очистки обёртки над элементом</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolElement`1.FreeWrapperInternal">
            <summary>
            Удаление элемента из обёртки
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolElement`1.Dispose">
            <summary>
            Явное освобождение элемента
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolElement`1.Finalize">
            <summary>
            Деструктор
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.PoolElement`1.Element">
            <summary>
            Обёрнутый элемент
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.PoolElement`1.Pool">
            <summary>
            Ссылка на пул
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.PoolElement`1.IsValid">
            <summary>
            Валиден ли элемент пула. Обязательно надо проверять.
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.PoolManagerBaseCodeContractCheck`2">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBaseCodeContractCheck`2.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.PoolManagerBaseCodeContractCheck`2.Rent(System.Int32,System.Threading.CancellationToken,System.Boolean)">
            <summary>Контракты</summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.PoolManagerBaseCodeContractCheck`2.ElementCount">
            <summary>Контракты</summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.PoolManagerBaseCodeContractCheck`2.FreeElementCount">
            <summary>Контракты</summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.PoolManagerBaseCodeContractCheck`2.RentedElementCount">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.StaticPoolManager`1">
            <summary>
            Пул с ручным заполнением элементами
            </summary>
            <typeparam name="T">Тип элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.#ctor(System.String,System.Boolean)">
            <summary>
            Конструктор StaticPoolManager
            </summary>
            <param name="name">Имя пула</param>
            <param name="disposeElementOnDestroy">Вызывать ли Dispose у элементов при их уничтожении</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.#ctor(System.String)">
            <summary>
            Конструктор StaticPoolManager
            </summary>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.#ctor">
            <summary>
            Конструктор StaticPoolManager
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.AddNewElement(`0)">
            <summary>
            Добавление нового элемента в пул
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.DestroyElement(`0)">
            <summary>
            Освобождение ресурсов элемента (точка расширения)
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.DestroyElementInner(`0)">
            <summary>
            Освобождение ресурсов элемента
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.RemoveElementInner(`0)">
            <summary>
            Удаление элемента из пула
            </summary>
            <param name="elem">Элемент</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.RemoveAndDestroyElementInner(`0)">
            <summary>
            Удалить и освободить ресурсы элемента
            </summary>
            <param name="elem">Элемент</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.RemoveElement(Core.ServiceClasses.Pool.PoolElement{`0},System.Boolean)">
            <summary>
            Удаление арендованного элемента из пула (напрмер, если стал не валиден)
            </summary>
            <param name="elemWrapper">Обёртка над элементом</param>
            <param name="disposeIfValid">Освободить ресурсы элемента</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.RemoveElement(Core.ServiceClasses.Pool.PoolElement{`0})">
            <summary>
            Удаление арендованного элемента из пула (напрмер, если стал не валиден)
            </summary>
            <param name="elemWrapper">Обёртка над элементом</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.Rent(System.Int32,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Арендовать элемент
            </summary>
            <param name="timeout">Таймаут (-1 - бесконечно, 0 - быстрая проверка, &gt; 0 - полная проверка)</param>
            <param name="token">Токен для отмены</param>
            <param name="throwOnUnavail">Выбрасывать исключение при недоступности элемента</param>
            <returns>Обёртка над элементом пула</returns>
            <exception cref="T:Core.ServiceClasses.CantRetrieveElementException">Если не удалось получить элемент и throwOnUnavail == true</exception>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.Core#ServiceClasses#Pool#IPoolElementReleaser{T}#Release(`0)">
            <summary>
            Освобождение элемента пула и добавление его к свободным
            </summary>
            <param name="elem">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.StaticPoolManager`1.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="P:Core.ServiceClasses.Pool.StaticPoolManager`1.PoolName">
            <summary>
            Имя пула
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.StaticPoolManager`1.ElementCount">
            <summary>
            Общее число элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.StaticPoolManager`1.FreeElementCount">
            <summary>
            Число свободных в данный момент элементов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Pool.StaticPoolManager`1.RentedElementCount">
            <summary>
            Число арендованных элементов в данный момент
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.UnifiedPoolElement`1">
            <summary>
            Обёртка над элементом пула с внешней проверкой валидности
            </summary>
            <typeparam name="T">Тип элемента пула</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedPoolElement`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedPoolElement`1.#ctor(Core.ServiceClasses.Pool.IPoolElementReleaser{`0},Core.ServiceClasses.Pool.IPoolElementValidator{`0},`0)">
            <summary>
            Конструктор UnifiedPoolElement
            </summary>
            <param name="pool">Менеджер пула, либо другой объект для освобождения элемента</param>
            <param name="validator">Объект, проверяющий валидность элемента</param>
            <param name="elem">Сам элемент</param>
        </member>
        <member name="P:Core.ServiceClasses.Pool.UnifiedPoolElement`1.IsValid">
            <summary>
            Валиден ли элемент пула. Обязательно надо проверять.
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1">
            <summary>
            Пул с балансировкой и изменением числа элементов при необходимости, а также унифицированной проверкой валидности элементов
            </summary>
            <typeparam name="T">Тип элемента пула</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.#ctor(System.Int32,System.Int32,System.Int32,System.Collections.Generic.IComparer{`0},System.String)">
            <summary>
            Конструктор UnifiedBalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.#ctor(System.Int32,System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Конструктор UnifiedBalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="getRetryTimeout">Время повтора между попытками получить новый элемент</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.#ctor(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0},System.String)">
            <summary>
            Конструктор UnifiedBalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.#ctor(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Конструктор UnifiedBalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор UnifiedBalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="trimPeriod">Время до уменьшения числа элементов (когда используются не все)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0},System.String)">
            <summary>
            Конструктор UnifiedBalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.#ctor(System.Int32,System.String)">
            <summary>
            Конструктор UnifiedBalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="name">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Конструктор UnifiedBalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
            <param name="elementComparer">Сравнение элементов с целью поиска наилучшего</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.#ctor(System.Int32)">
            <summary>
            Конструктор UnifiedBalancingDynamicSizePoolManager
            </summary>
            <param name="maxElemCount">Максимальное число элементов в пуле (-1 - неограничено)</param>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.CreatePoolElement(`0)">
            <summary>
            Создание обёртки над элементом.
            </summary>
            <param name="elem">Элемент</param>
            <returns>Обёртка</returns>
        </member>
        <member name="M:Core.ServiceClasses.Pool.UnifiedBalancingDynamicSizePoolManager`1.Core#ServiceClasses#Pool#IPoolElementValidator{T}#IsValid(`0)">
            <summary>
            Можно ли использовать данный объект (Реализация интерфейса IPoolElementValidator)
            </summary>
            <param name="elem">Объект</param>
            <returns>Валиден ли объект</returns>
        </member>
        <member name="T:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider">
            <summary>
            Интерфейс профилировщика для сервисных классов
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.PoolElementRentedTime(System.String,System.TimeSpan)">
            <summary>
            Оценка времени, в течение которого элемент пула был арендован
            </summary>
            <param name="poolName">Имя пула</param>
            <param name="time">Время удержания</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.PoolElementReleasedInFinalizer(System.String)">
            <summary>
            Элемент пула был освобождён в финализаторе (плохое поведение)
            </summary>
            <param name="poolName">Имя пула</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.PoolElementRented(System.String,System.Int32)">
            <summary>
            Оценка числа арендованных элементов (вызывается при аренде нового элемента)
            </summary>
            <param name="poolName">Имя пула</param>
            <param name="newRentedCount">Текущее число арендованных элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.PoolElementReleased(System.String,System.Int32)">
            <summary>
            Оценка числа арендованных элементов (вызывается при освобождении арендованного элемента)
            </summary>
            <param name="poolName">Имя пула</param>
            <param name="newRentedCount">Текущее число арендованных элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.PoolElementFaulted(System.String,System.Int32)">
            <summary>
            Уведомление о том, что элемент пула перешёл в непригодное для использования состояние
            </summary>
            <param name="poolName">Имя пула</param>
            <param name="activeElementCount">Текущее число элементов в пуле</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.PoolElementCreated(System.String,System.Int32)">
            <summary>
            Создан новый элемент в пуле
            </summary>
            <param name="poolName">Имя пула</param>
            <param name="activeElementCount">Текущее число элементов в пуле</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.PoolElementDestroyed(System.String,System.Int32)">
            <summary>
            Элемент пула уничтожен
            </summary>
            <param name="poolName">Имя пула</param>
            <param name="activeElementCount">Текущее число элементов в пуле</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.QueueAsyncProcessorThreadStart(System.String,System.Int32,System.Int32)">
            <summary>
            Запустился поток в асинхронном обработчике
            </summary>
            <param name="queueProcName">Имя обработчика</param>
            <param name="curThreadCount">Текущее число потоков</param>
            <param name="expectedThreadCount">Ожидаемое число потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.QueueAsyncProcessorThreadStop(System.String,System.Int32,System.Int32)">
            <summary>
            Остановился поток в асинхронном обработчике (либо по завершению, либо из-за ошибки)
            </summary>
            <param name="queueProcName">Имя обработчика</param>
            <param name="curThreadCount">Текущее число потоков</param>
            <param name="expectedThreadCount">Ожидаемое число потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.QueueAsyncProcessorProcessTime(System.String,System.TimeSpan)">
            <summary>
            Оценка времени обработки элемента в асинхронном обработчике
            </summary>
            <param name="queueProcName">Имя обработчика</param>
            <param name="time">Время обработки</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.QueueAsyncProcessorElementCountIncreased(System.String,System.Int32,System.Int32)">
            <summary>
            Оценка числа элементов в очереди на обработку внутри асинхронного обработчика
            </summary>
            <param name="queueProcName">Имя обработчика</param>
            <param name="newElementCount">Число элементов в очереди</param>
            <param name="maxElementCount">Максимальное число элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.QueueAsyncProcessorElementCountDecreased(System.String,System.Int32,System.Int32)">
            <summary>
            Оценка числа элементов в очереди на обработку внутри асинхронного обработчика
            </summary>
            <param name="queueProcName">Имя обработчика</param>
            <param name="newElementCount">Число элементов в очереди</param>
            <param name="maxElementCount">Максимальное число элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.QueueAsyncProcessorElementRejectedInTryAdd(System.String,System.Int32)">
            <summary>
            Вызывается при отбрасывании элемента в TryAdd в случае переполненности очереди
            </summary>
            <param name="queueProcName">Имя обработчика</param>
            <param name="currentElementCount">Число элементов в очереди</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.QueueAsyncProcessorFinalizerRun(System.String)">
            <summary>
            Асинхронный обработчик завершился в финализаторе (плохое поведение)
            </summary>
            <param name="queueProcName">Имя обработчика</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.ThreadPoolThreadStart(System.String,System.Int32,System.Int32)">
            <summary>
            Запустился новый поток в пуле потоков
            </summary>
            <param name="threadPoolName">Имя пула потоков</param>
            <param name="curThreadCount">Текущее число потоков</param>
            <param name="maxThreadCount">Максимально возможное число потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.ThreadPoolThreadStop(System.String,System.Int32,System.Int32)">
            <summary>
            Остановился поток в пуле потоков
            </summary>
            <param name="threadPoolName">Имя пула потоков</param>
            <param name="curThreadCount">Текущее число потоков</param>
            <param name="maxThreadCount">Максимально возможное число потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.ThreadPoolWaitingInQueueTime(System.String,System.TimeSpan)">
            <summary>
            Оценка времени ожидания выполнения задачи в пуле потоков (время нахождения в очереди)
            </summary>
            <param name="threadPoolName">Имя пула потоков</param>
            <param name="time">Время нахождения в очереди</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.ThreadPoolWorkProcessTime(System.String,System.TimeSpan)">
            <summary>
            Оценка времени выполнения задачи в пуле потоков
            </summary>
            <param name="threadPoolName">Имя пула потоков</param>
            <param name="time">Время исполнения</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.ThreadPoolWorkItemsCountIncreased(System.String,System.Int32,System.Int32)">
            <summary>
            Изменилось число задач в очереди на обработку в пуле потоков
            </summary>
            <param name="threadPoolName">Имя пула потоков</param>
            <param name="newItemCount">Текущее число задач в очереди</param>
            <param name="maxItemCount">Максимальное число задач в очереди</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.ThreadPoolWorkItemsCountDecreased(System.String,System.Int32,System.Int32)">
            <summary>
            Изменилось число задач в очереди на обработку в пуле потоков
            </summary>
            <param name="threadPoolName">Имя пула потоков</param>
            <param name="newItemCount">Текущее число задач в очереди</param>
            <param name="maxItemCount">Максимальное число задач в очереди</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.ThreadPoolWorkItemRejectedInTryAdd(System.String,System.Int32)">
            <summary>
            Вызывается при отбрасывании задачи в TryAdd в случае переполненности очереди
            </summary>
            <param name="threadPoolName">Имя пула потоков</param>
            <param name="currentItemCount">Текущее число задач в очереди</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.ThreadPoolWorkItemRunInSync(System.String)">
            <summary>
            Пул исполнил задачу в синхронном режиме (задача была вызвана из пула потоков и свободных мест не было)
            </summary>
            <param name="threadPoolName">Имя пула потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider.ThreadPoolFinalizerRun(System.String)">
            <summary>
            Пул потоков завершился в финализаторе (плохое поведение)
            </summary>
            <param name="threadPoolName">Имя пула потоков</param>
        </member>
        <member name="T:Core.ServiceClasses.Profiling.ProfilingTimer">
            <summary>
            Таймер для профилировки
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Profiling.ServiceClassesProfiler">
            <summary>
            Класс профилировщика
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Profiling.ServiceClassesProfiler.SetProfiler(Core.ServiceClasses.Profiling.IServiceClassesProfilingProvider)">
            <summary>
            Задать профилировщик
            </summary>
            <param name="profiler">Профилировщик</param>
        </member>
        <member name="T:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1">
            <summary>
            Асинхронная обработка на делегатах.
            Лучше не использовать, а самостоятельно наследоваться от QueueAsyncProcessor
            </summary>
            <typeparam name="T">Тип обрабатываемого элемента</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1">
            <summary>
            Асинхронный обработчик данных в несколько потоков с очередью
            </summary>
            <typeparam name="T">Тип обрабатываемого элемента</typeparam>
        </member>
        <member name="T:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorBase`1">
            <summary>
            Базовый класс для асинхронных обработчиков
            </summary>
            <typeparam name="T">Тип обрабатываемого элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorBase`1.TryAdd(`0)">
            <summary>
            Попытаться добавить элемент на обработку
            </summary>
            <param name="element">Элемент</param>
            <returns>Удалось ли добавить</returns>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorBase`1.Add(`0)">
            <summary>
            Добавление элемента на обработку
            </summary>
            <param name="element">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorBase`1.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorBase`1.Dispose">
            <summary>
            Освобождение ресурсов
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.String,System.Boolean,System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>
            Конструктор QueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков обработки</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя, присваемое потокам</param>
            <param name="isBackground">Будут ли потоки работать в фоновом режиме</param>
            <param name="customCollection">Коллекция - контейнер</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.String,System.Boolean)">
            <summary>
            Конструктор QueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков обработки</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя, присваемое потокам</param>
            <param name="isBackground">Будут ли потоки работать в фоновом режиме</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор QueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков обработки</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя, присваемое потокам</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор QueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков обработки</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.#ctor(System.Int32)">
            <summary>
            Конструктор QueueAsyncProcessor. Размер очереди не ограничивается.
            </summary>
            <param name="processorCount">Число потоков обработки</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Start">
            <summary>
            Запуск обработчиков.
            Возможен перезапуск после вызова метода Stop()
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Stop(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Остановка работы асинхронного обработчика
            </summary>
            <param name="waitForStop">Ждать ли завершения всех потоков</param>
            <param name="letFinishProcess">Позволить закончить обработку того, что есть в очереди</param>
            <param name="completeAdding">Заблокировать добавление новых элементов</param>
            <returns>Запущен ли процесс остановки</returns>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Stop">
            <summary>
            Остановка работы асинхронного обработчика
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.WaitUntilStop">
            <summary>
            Ожидание полной остановки
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.WaitUntilStop(System.Int32)">
            <summary>
            Ожидание полной остановки с таймаутом
            </summary>
            <param name="timeout">Таймаут ожидания в миллисекундах</param>
            <returns>true - дождались, false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.TryAdd(`0)">
            <summary>
            Попытаться добавить элемент на обработку
            </summary>
            <param name="element">Элемент</param>
            <returns>Удалось ли добавить</returns>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Add(`0)">
            <summary>
            Добавление элемента на обработку
            </summary>
            <param name="element">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.ExtractToken">
            <summary>
            Извлечение токена отмены. (Обрабатывает ситуацию, когда _threadWaitCancelation == null)
            </summary>
            <returns>Токен отмены</returns>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.ThreadProcFunc">
            <summary>
            Основноя функция, выполняемая потоками
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.ProcessThreadException(System.Exception)">
            <summary>
            Обработка исключений. 
            Чтобы исключение было проброшено наверх, нужно выбросить новое исключение внутри метода.
            </summary>
            <param name="ex">Исключение</param>
            <returns>Игнорировать ли исключение (false - поток завершает работу)</returns>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Prepare">
            <summary>
            Создание объекта состояния на поток.
            Вызывается при старте для каждого потока
            </summary>
            <returns>Объект состояния</returns>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Process(`0,System.Object,System.Threading.CancellationToken)">
            <summary>
            Основной метод обработки элементов.
            Если токен в состоянии Cancelled, то следует делать обработку по ускоренному сценарию, 
            т.к. вызов может прийти после остановки в режиме ожидания завершения. Проверить это можно по свойству State.
            </summary>
            <param name="element">Элемент</param>
            <param name="state">Объект состояния, инициализированный в методе Prepare()</param>
            <param name="token">Токен для отмены обработки при вызове Stop</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Finalize(System.Object)">
            <summary>
            Освобождение объекта состояния потока
            </summary>
            <param name="state">Объект состояния</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Finalize">
            <summary>
            Финализатор
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.IsWorkState">
            <summary>
            Запущен ли сейчас обработчик
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.Name">
            <summary>
            Имя обработчика
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.IsBackground">
            <summary>
            Работают ли потоки в фоновом режиме
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.ProcessorCount">
            <summary>
            Число потоков обработки
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.ElementCount">
            <summary>
            Число элементов в очереди
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.State">
            <summary>
            Текущее состояние
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessor`1.IsStopingRequested">
            <summary>
            Запрошена ли остановка потоков
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.String,System.Boolean,System.Action{`0},System.Action{System.Exception},System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>
            Конструктор DeleageQueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя для потоков</param>
            <param name="isBackground">Будут ли потоки работать в фоновом режиме</param>
            <param name="processing">Делегат обработки элементов</param>
            <param name="exceptionAct">Делегат обработки исключений</param>
            <param name="customCollection">Коллекция - контейнер</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.String,System.Boolean,System.Action{`0},System.Action{System.Exception})">
            <summary>
            Конструктор DeleageQueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя для потоков</param>
            <param name="isBackground">Будут ли потоки работать в фоновом режиме</param>
            <param name="processing">Делегат обработки элементов</param>
            <param name="exceptionAct">Делегат обработки исключений</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.String,System.Boolean,System.Action{`0})">
            <summary>
            Конструктор DeleageQueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя для потоков</param>
            <param name="isBackground">Будут ли потоки работать в фоновом режиме</param>
            <param name="processing">Делегат обработки элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.String,System.Action{`0},System.Action{System.Exception})">
            <summary>
            Конструктор DeleageQueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя для потоков</param>
            <param name="processing">Делегат обработки элементов</param>
            <param name="exceptionAct">Делегат обработки исключений</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.String,System.Action{`0})">
            <summary>
            Конструктор DeleageQueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя для потоков</param>
            <param name="processing">Делегат обработки элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.Action{`0},System.Action{System.Exception})">
            <summary>
            Конструктор DeleageQueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="processing">Делегат обработки элементов</param>
            <param name="exceptionAct">Делегат обработки исключений</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.#ctor(System.Int32,System.Int32,System.Action{`0})">
            <summary>
            Конструктор DeleageQueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="processing">Делегат обработки элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.#ctor(System.Int32,System.Action{`0})">
            <summary>
            Конструктор DeleageQueueAsyncProcessor
            </summary>
            <param name="processorCount">Число потоков</param>
            <param name="processing">Делегат обработки элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.Process(`0,System.Object,System.Threading.CancellationToken)">
            <summary>
            Основной метод обработки элементов
            </summary>
            <param name="element">Элемент</param>
            <param name="state">Объект состояния, инициализированный в методе Prepare()</param>
            <param name="token">Токен для отмены обработки</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.ContinueWith(`0,System.Action{`0})">
            <summary>
            Добавляет element на обработку.
            processing должен совпадать с методом из конструктора.
            Цель метода - повышение наглядности
            </summary>
            <param name="element">Элемент</param>
            <param name="processing">Исполнитель</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.DeleageQueueAsyncProcessor`1.ProcessThreadException(System.Exception)">
            <summary>
            Обработка исключений. 
            Чтобы исключение было проброшено наверх, нужно выбросить новое исключение внутри метода.
            </summary>
            <param name="ex">Исключение</param>
            <returns>Игнорировать ли исключение (false - поток завершает работу)</returns>
        </member>
        <member name="T:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1">
            <summary>
            Асинхронная обработка на интерфейсе.
            </summary>
            <typeparam name="T">Тип обрабатываемого элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.#ctor(Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogic{`0},System.Int32,System.Int32,System.String,System.Boolean,System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>
            Конструктор InterfaceBasedQueueAsyncProcessor
            </summary>
            <param name="logic">Интерфейс с логикой обработки данных</param>
            <param name="processorCount">Число потоков обработки</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя, присваемое потокам</param>
            <param name="isBackground">Будут ли потоки работать в фоновом режиме</param>
            <param name="customCollection">Коллекция - контейнер</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.#ctor(Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogic{`0},System.Int32,System.Int32,System.String,System.Boolean)">
            <summary>
            Конструктор InterfaceBasedQueueAsyncProcessor
            </summary>
            <param name="logic">Интерфейс с логикой обработки данных</param>
            <param name="processorCount">Число потоков обработки</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя, присваемое потокам</param>
            <param name="isBackground">Будут ли потоки работать в фоновом режиме</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.#ctor(Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogic{`0},System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор InterfaceBasedQueueAsyncProcessor
            </summary>
            <param name="logic">Интерфейс с логикой обработки данных</param>
            <param name="processorCount">Число потоков обработки</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
            <param name="name">Имя, присваемое потокам</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.#ctor(Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogic{`0},System.Int32,System.Int32)">
            <summary>
            Конструктор InterfaceBasedQueueAsyncProcessor
            </summary>
            <param name="logic">Интерфейс с логикой обработки данных</param>
            <param name="processorCount">Число потоков обработки</param>
            <param name="maxQueueSize">Максимальный размер очереди</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.#ctor(Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogic{`0},System.Int32)">
            <summary>
            Конструктор InterfaceBasedQueueAsyncProcessor
            </summary>
            <param name="logic">Интерфейс с логикой обработки данных</param>
            <param name="processorCount">Число потоков обработки</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.Prepare">
            <summary>
            Создание объекта состояния на поток.
            Вызывается при старте для каждого потока
            </summary>
            <returns>Объект состояния</returns>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.Finalize(System.Object)">
            <summary>
            Освобождение объекта состояния потока
            </summary>
            <param name="state">Объект состояния</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.Process(`0,System.Object,System.Threading.CancellationToken)">
            <summary>
            Основной метод обработки элементов
            </summary>
            <param name="element">Элемент</param>
            <param name="state">Объект состояния, инициализированный в методе Prepare()</param>
            <param name="token">Токен для отмены обработки</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.InterfaceBasedQueueAsyncProcessor`1.ProcessThreadException(System.Exception)">
            <summary>
            Обработка исключений. 
            Чтобы исключение было проброшено наверх, нужно выбросить новое исключение внутри метода.
            </summary>
            <param name="ex">Исключение</param>
            <returns>Игнорировать ли исключение (false - поток завершает работу)</returns>
        </member>
        <member name="T:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogic`1">
            <summary>
            Интерфейс с логикой асинхронной обработки данных
            </summary>
            <typeparam name="T">Тип обрабатываемого элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogic`1.Process(`0,System.Threading.CancellationToken,System.Object)">
            <summary>
            Основной метод обработки элементов
            </summary>
            <param name="element">Элемент</param>
            <param name="token">Токен для отмены обработки</param>
            <param name="state">Объект состояния, инициализированный в методе Prepare()</param>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogic`1.ProcessThreadException(System.Exception)">
            <summary>
            Обработка исключений. 
            Чтобы исключение было проброшено наверх, нужно вернуть false, либо самостоятельно выбросить новое исключение внутри метода.
            </summary>
            <param name="ex">Исключение</param>
            <returns>Игнорировать ли исключение (false - поток завершает работу)</returns>
        </member>
        <member name="T:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicExt`1">
            <summary>
            Интерфейс с расширенной логикой асинхронной обработки данных
            </summary>
            <typeparam name="T">Тип обрабатываемого элемента</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicExt`1.Prepare">
            <summary>
            Создание объекта состояния на поток.
            Вызывается при старте для каждого потока
            </summary>
            <returns>Объект состояния</returns>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicExt`1.Finalize(System.Object)">
            <summary>
            Освобождение объекта состояния потока
            </summary>
            <param name="state">Объект состояния</param>
        </member>
        <member name="T:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicCodeContractCheck`1.ProcessThreadException(System.Exception)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicCodeContractCheck`1.Process(`0,System.Threading.CancellationToken,System.Object)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicExtCodeContractCheck`1">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicExtCodeContractCheck`1.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicExtCodeContractCheck`1.Prepare">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicExtCodeContractCheck`1.Finalize(System.Object)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicExtCodeContractCheck`1.Process(`0,System.Threading.CancellationToken,System.Object)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.QueueProcessing.IQueueAsyncProcessorLogicExtCodeContractCheck`1.ProcessThreadException(System.Exception)">
            <summary>Контракты</summary>
        </member>
        <member name="T:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorState">
            <summary>
            Состояние асинхронного обработчика
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorState.Created">
            <summary>
            Создан
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorState.StartPending">
            <summary>
            В процессе запуска
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorState.InWork">
            <summary>
            Работает
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorState.StopPending">
            <summary>
            В процессе остановки
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorState.Stopped">
            <summary>
            Остановлен
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.QueueProcessing.QueueAsyncProcessorState.Disposed">
            <summary>
            Уничтожен
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.SignalObjects.AsyncSignalObject">
            <summary>
            Объект сигнализации о наступлении события
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.SignalObjects.AsyncSignalObject.SendSignal">
            <summary>
            Послать сигнал
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.SignalObjects.AsyncSignalExtObject">
            <summary>
            Объект сигнализации о наступлении события, либо ошибке
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.SignalObjects.AsyncSignalExtObject.SendFaultedSignal(System.Exception)">
            <summary>
            Послать сигнал об ошибке
            </summary>
            <param name="ex">Исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.SignalObjects.DelegateBasedAsyncSignalObject">
            <summary>
            Объект сигнализации о наступлении события на делегате
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.SignalObjects.DelegateBasedAsyncSignalObject.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.SignalObjects.DelegateBasedAsyncSignalObject.#ctor(System.Action)">
            <summary>
            Конструктор
            </summary>
            <param name="signal">Делегат сигнализации</param>
        </member>
        <member name="M:Core.ServiceClasses.SignalObjects.DelegateBasedAsyncSignalObject.SendSignal">
            <summary>
            Послать сигнал
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.SignalObjects.DelegateBasedAsyncSignalExtObject">
            <summary>
            Объект сигнализации о наступлении события на делегате
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.SignalObjects.DelegateBasedAsyncSignalExtObject.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.SignalObjects.DelegateBasedAsyncSignalExtObject.#ctor(System.Action,System.Action{System.Exception})">
            <summary>
            Конструктор
            </summary>
            <param name="signal">Делегат сигнализации</param>
            <param name="faultSignal">Делегат сигнализации об ошибке</param>
        </member>
        <member name="M:Core.ServiceClasses.SignalObjects.DelegateBasedAsyncSignalExtObject.SendSignal">
            <summary>
            Послать сигнал
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.SignalObjects.DelegateBasedAsyncSignalExtObject.SendFaultedSignal(System.Exception)">
            <summary>
            Послать сигнал об ошибке
            </summary>
            <param name="ex">Исключение</param>
        </member>
        <member name="T:Core.ServiceClasses.Threading.EntryCountingEventGuard">
            <summary>
            Примитив для использования using с EntryCountingEvent
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEventGuard.#ctor(Core.ServiceClasses.Threading.EntryCountingEvent)">
            <summary>
            Конструктор EntryCountingEventGuard
            </summary>
            <param name="srcCounter">EntryCountingEvent</param>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEventGuard.Dispose">
            <summary>
            Выход из экранируемого блока
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Threading.EntryCountingEventGuard.IsAcquired">
            <summary>
            Удалось ли войти в экранируемый блок
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Threading.EntryCountingEvent">
            <summary>
            Примитив для ожидания завершения исполнения всех экранируемых блоков
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.#ctor">
            <summary>
            Констрктор EntryCountingEvent
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.TryEnterClient">
            <summary>
            Попробовать зайти в экранируемый блок
            </summary>
            <returns>Удалось ли зайти в блок</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.EnterClient">
            <summary>
            Выполнить заход в экранируемый блок (исключение, если не удалось войти)
            </summary>
            <exception cref="T:System.ObjectDisposedException">Освобождён</exception>
            <exception cref="T:System.InvalidOperationException">Завершён</exception>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.TryEnterClientGuarded">
            <summary>
            Попытаться войти в жкранируемый блок с guard объектом
            </summary>
            <returns></returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.EnterClientGuarded">
            <summary>
            Войти в блок с guard объектом (исключение, если не удалось войти)
            </summary>
            <returns>Guard</returns>
            <exception cref="T:System.ObjectDisposedException">Освобождён</exception>
            <exception cref="T:System.InvalidOperationException">Завершён</exception>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.EnterClientGuardedWithException(System.Func{System.Exception})">
            <summary>
            Войти в блок с guard объектом и, если не удалось, то выбросить пользовательское исключение
            </summary>
            <param name="userExceptionGenerator">Конструктор пользовательского исключения</param>
            <returns>Guard</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.ExitClient">
            <summary>
            Выйти из экранируемого блока
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.TryEnterClientConditional(System.Func{System.Boolean})">
            <summary>
            Попробовать зайти в экранируемый блок с дополнительным условием
            </summary>
            <param name="condition">Условие</param>
            <returns>Удалось ли войти</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.Terminate">
            <summary>
            Выполнить остановку (новые клиенты не смогут войти)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.Wait">
            <summary>
            Дождаться завершения исполнения всех блоков
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.Wait(System.Threading.CancellationToken)">
            <summary>
            Дождаться завершения исполнения всех блоков
            </summary>
            <param name="cancellationToken">Токен отмены</param>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.Wait(System.TimeSpan)">
            <summary>
            Дождаться завершения исполнения всех блоков
            </summary>
            <param name="timeout">Таймаут</param>
            <returns>false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.Wait(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Дождаться завершения исполнения всех блоков
            </summary>
            <param name="timeout">Таймаут</param>
            <param name="cancellationToken">Токен отмены</param>
            <returns>false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.Wait(System.Int32)">
            <summary>
            Дождаться завершения исполнения всех блоков
            </summary>
            <param name="millisecondsTimeout">Таймаут</param>
            <returns>false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.Wait(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Дождаться завершения исполнения всех блоков
            </summary>
            <param name="millisecondsTimeout">Таймаут</param>
            <param name="cancellationToken">Токен отмены</param>
            <returns>false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.TerminateAndWait">
            <summary>
            Остановить и дождаться завершения исполнения всех блоков
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.TerminateAndWait(System.Threading.CancellationToken)">
            <summary>
            Остановить и дождаться завершения исполнения всех блоков
            </summary>
            <param name="cancellationToken">Токен отмены</param>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.TerminateAndWait(System.TimeSpan)">
            <summary>
            Остановить и дождаться завершения исполнения всех блоков
            </summary>
            <param name="timeout">Таймаут</param>
            <returns>false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.TerminateAndWait(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Остановить и дождаться завершения исполнения всех блоков
            </summary>
            <param name="timeout">Таймаут</param>
            <param name="cancellationToken">Токен отмены</param>
            <returns>false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.TerminateAndWait(System.Int32)">
            <summary>
            Остановить и дождаться завершения исполнения всех блоков
            </summary>
            <param name="millisecondsTimeout">Таймаут</param>
            <returns>false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.TerminateAndWait(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Остановить и дождаться завершения исполнения всех блоков
            </summary>
            <param name="millisecondsTimeout">Таймаут</param>
            <param name="cancellationToken">Токен отмены</param>
            <returns>false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.Dispose(System.Boolean)">
            <summary>
            Освободить ресурсы
            </summary>
            <param name="isUserCall">Вызвано ли явно</param>
        </member>
        <member name="M:Core.ServiceClasses.Threading.EntryCountingEvent.Dispose">
            <summary>
            Освободить ресурсы
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Threading.EntryCountingEvent.CurrentCount">
            <summary>
            Текущее количество входов
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Threading.EntryCountingEvent.IsTerminateRequested">
            <summary>
            Запрошена ли остановка
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Threading.EntryCountingEvent.IsTerminated">
            <summary>
            Выполнена ли остановка полностью
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.Threading.EntryCountingEvent.WaitHandle">
            <summary>
            Объект ожидания
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool">
            <summary>
            Общий вспомогательный класс для пула потоков
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.ThreadPools.ThreadPoolBase">
            <summary>
            Базовый класс пула потоков
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.AddWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Добавление задачи для пула потоков
            </summary>
            <param name="item">Задача</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.TryAddWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Попытаться добавить задачу в пул потоков
            </summary>
            <param name="item">Задача</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.Run(System.Action)">
            <summary>
            Исполнение метода в пуле потоков
            </summary>
            <param name="act">Делегат на выполняемый метод</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.TryRun(System.Action)">
            <summary>
            Попытаться исполнить метод в пуле потоков
            </summary>
            <param name="act">Делегат на выполняемый метод</param>
            <returns>Успшеность постановки в очередь (не гарантирует успешность запуска)</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.RunWithState``1(System.Action{``0},``0)">
            <summary>
            Исполнение метода с пользовательским параметром в пуле потоков
            </summary>
            <typeparam name="T">Тип пользовательского параметра</typeparam>
            <param name="act">Делегат на выполняемый метод</param>
            <param name="state">Пользовательский параметр</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.TryRunWithState``1(System.Action{``0},``0)">
            <summary>
            Попытаться исполнить метод с пользовательским параметром в пуле потоков
            </summary>
            <typeparam name="T">Тип пользовательского параметра</typeparam>
            <param name="act">Делегат на выполняемый метод</param>
            <param name="state">Пользовательский параметр</param>
            <returns>Успшеность постановки в очередь (не гарантирует успешность запуска)</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.RunAsTask(System.Action)">
            <summary>
            Запуск действия с обёртыванием в Task
            </summary>
            <param name="act">Действие</param>
            <returns>Task</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.RunAsTask``1(System.Func{``0})">
            <summary>
            Запуск функции с обёртыванием в Task
            </summary>
            <typeparam name="T">Тип результата</typeparam>
            <param name="fnc">Функций</param>
            <returns>Task</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.SwitchToPool">
            <summary>
            Переход на выполнение в пуле посредством await
            </summary>
            <returns>Объект смены контекста выполнения</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.Core#ServiceClasses#IConsumer{System#Action}#Add(System.Action)">
            <summary>
            Добавить элемент
            </summary>
            <param name="item">Элемент</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.Core#ServiceClasses#IConsumer{System#Action}#TryAdd(System.Action)">
            <summary>
            Попытаться добавить элемент
            </summary>
            <param name="item">Элемент</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBase.Dispose">
            <summary>
            Освобождение ресурсов
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool._isPoolThread">
            <summary>
            True для потоков из пула
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool._synchroContext">
            <summary>
            Собственный контекст синхронизации (если null, то не применяется)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.#ctor(System.Boolean,System.String,System.Boolean,System.Boolean)">
            <summary>
            Конструктор CommonThreadPool
            </summary>
            <param name="isBackground">Фоновые ли потоки</param>
            <param name="name">Имя пула</param>
            <param name="useOwnSyncContext">Устанавливать ли собственный контекст синхронизации</param>
            <param name="flowContext">Протаскивать ли контекст исполнения</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.OnNewWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem@)">
            <summary>
            Обработка свежей задачи при поступлении
            </summary>
            <param name="item">Задача</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.AddWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Добавление задачи для пула потоков
            </summary>
            <param name="item">Задача</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.TryAddWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Попытаться добавить задачу в пул потоков
            </summary>
            <param name="item">Задача</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.AddWorkItemInner(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Добавление задачи для пула потоков
            </summary>
            <param name="item">Задача</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.TryAddWorkItemInner(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Попытаться добавить задачу в пул потоков
            </summary>
            <param name="item">Задача</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.IsPoolThread">
            <summary>
            Проверка, принадлежит ли текущий поток пулу
            </summary>
            <returns>ДА или НЕТ</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.CreateNewThread(System.Threading.ThreadStart,Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadStartControllingToken)">
            <summary>
            Создаёт новый объект потока
            </summary>
            <param name="start">Метод потока</param>
            <param name="startController">Контроллер запуска потока</param>
            <returns>Созданный поток</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.DoOnThreadStart(System.Threading.ThreadLocal{System.Boolean},System.Threading.SynchronizationContext)">
            <summary>
            Действия, выполняемые при запуске потока
            </summary>
            <param name="isPoolThread">Переменная, определяющая, принадлежит ли поток данному пулу</param>
            <param name="syncContext">Контекст синхронизации</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.RunWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem,System.Boolean)">
            <summary>
            Запуск задания
            </summary>
            <param name="item">Задача</param>
            <param name="suppressContextRestore">Подавлять ли восстановление контекста исполнения</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.SwitchToPool">
            <summary>
            Переход на выполнение в пуле посредством await
            </summary>
            <returns>Объект смены контекста выполнения</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.Core#ServiceClasses#AsyncAwaitSupport#IContextSwitchSupplier#Run(System.Action,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.Core#ServiceClasses#AsyncAwaitSupport#IContextSwitchSupplier#RunWithState(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="state">Состояние</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.Core#ServiceClasses#AsyncAwaitSupport#ICustomSynchronizationContextSupplier#RunAsync(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Асинхронное выполнение задания
            </summary>
            <param name="act">Задание</param>
            <param name="state">Состояние</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.Core#ServiceClasses#AsyncAwaitSupport#ICustomSynchronizationContextSupplier#RunSync(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Синхронное выполнение задание
            </summary>
            <param name="act">Задание</param>
            <param name="state">Состояние</param>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.ServiceStuff.CommonThreadPool.Name">
            <summary>
            Имя потоков пула
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.ThreadPools.DynamicThreadPool">
            <summary>
            Пул потоков с динамическим изменением числа задействованных потоков
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.DynamicThreadPool.TestThreadRecursion">
            <summary>
            Обнаруживать ли запуск задачи из одного из потоков пула (для предотвращения dead-lock'а)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.DynamicThreadPool._activeThread">
            <summary>
            Список всех потоков
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.DynamicThreadPool._actQueue">
            <summary>
            Очередь задач
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Конструктор DynamicThreadPool
            </summary>
            <param name="maxThreadCount">Максимальное число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
            <param name="trimPeriod">Периоды уменьшения числа потоков при их неиспользовании в миллисекундах (-1 - бесконечность)</param>
            <param name="maxRescueThreadCount">Максимальное число спасательных потоков</param>
            <param name="rescureThreadCreationInterval">Интервал создания спасательных потоков (когда нет продвижения задач) (-1 ~ 4 секунды)</param>
            <param name="isBackground">Использовать ли фоновые потоки</param>
            <param name="name">Имена потоков</param>
            <param name="isRecursiveSync">Разрешение выполнять задачи синхронно в случае рекурсивной постановки</param>
            <param name="useOwnSyncContext">Использовать ли свой контекст синхронизации</param>
            <param name="flowContext">Протаскивать ли контекст исполнения</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.String,System.Boolean)">
            <summary>
            Конструктор DynamicThreadPool
            </summary>
            <param name="maxThreadCount">Максимальное число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
            <param name="trimPeriod">Периоды уменьшения числа потоков при их неиспользовании в миллисекундах (-1 - бесконечность)</param>
            <param name="maxRescueThreadCount">Максимальное число спасательных потоков</param>
            <param name="isBackground">Использовать ли фоновые потоки</param>
            <param name="name">Имена потоков</param>
            <param name="isRecursiveSync">Разрешение выполнять задачи синхронно в случае рекурсивной постановки</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Конструктор DynamicThreadPool
            </summary>
            <param name="maxThreadCount">Максимальное число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
            <param name="trimPeriod">Периоды уменьшения числа потоков при их неиспользовании (-1 - бесконечность)</param>
            <param name="maxRescueThreadCount">Максимальное число спасательных потоков</param>
            <param name="isBackground">Использовать ли фоновые потоки</param>
            <param name="name">Имена потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор DynamicThreadPool
            </summary>
            <param name="maxThreadCount">Максимальное число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
            <param name="trimPeriod">Периоды уменьшения числа потоков при их неиспользовании (-1 - бесконечность)</param>
            <param name="maxRescueThreadCount">Максимальное число спасательных потоков</param>
            <param name="name">Имена потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.#ctor(System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Конструктор DynamicThreadPool
            </summary>
            <param name="maxThreadCount">Максимальное число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
            <param name="isBackground">Использовать ли фоновые потоки</param>
            <param name="name">Имена потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор DynamicThreadPool
            </summary>
            <param name="maxThreadCount">Максимальное число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
            <param name="name">Имена потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор DynamicThreadPool
            </summary>
            <param name="maxThreadCount">Максимальное число потоков</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.#ctor(System.Int32,System.String)">
            <summary>
            Конструктор DynamicThreadPool
            </summary>
            <param name="maxThreadCount">Максимальное число потоков</param>
            <param name="name">Имена потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.#ctor(System.Int32)">
            <summary>
            Конструктор DynamicThreadPool
            </summary>
            <param name="maxThreadCount">Максимальное число потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.GetTimeMeasureInMs">
            <summary>
            Получить отсчёт времени в миллисекундах
            </summary>
            <returns>Текущее значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.FillPoolUpTo(System.Int32)">
            <summary>
            Наполнить пул до count потоков
            </summary>
            <param name="count">Число потоков, до которого наполняем</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.InitNewThread(System.Boolean)">
            <summary>
            Создание и запуск нового потока
            </summary>
            <returns>Новый поток</returns>
            <param name="isRescue">Создаётся ли спасательный поток</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.RemoveElement(System.Threading.Thread)">
            <summary>
            Удаление потока из пула (предполагается, что поток уже завершился или находится на стадии завершения)
            </summary>
            <param name="elem">Поток</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.ShouldIDie">
            <summary>
            Проверяет, должен ли поток завершится, если присутствуют бездействующие потоки
            </summary>
            <returns>Должен ли завершиться</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.ThreadProc">
            <summary>
            Процедура потока
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.RescueSpawnThreadProc">
            <summary>
            Функция потока, выполняющего отслеживание необходимости создания спасательных потоков
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.AddWorkItemInner(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Добавление задачи для пула потоков
            </summary>
            <param name="item">Задача</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.TryAddWorkItemInner(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Попытаться добавить задачу в пул потоков
            </summary>
            <param name="item">Задача</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.StopInner(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Внутренняя остановка пула
            </summary>
            <param name="waitForStop">Ожидать остановки</param>
            <param name="letFinishProcess">Позволить обработать всю очередь</param>
            <param name="completeAdding">Запретить добавление новых элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.WaitUntilStop">
            <summary>
            Ожидание полной остановки
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.WaitUntilStop(System.Int32)">
            <summary>
            Ожидание полной остановки с таймаутом
            </summary>
            <param name="timeout">Таймаут ожидания в миллисекундах</param>
            <returns>true - дождались, false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.Dispose(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Остановка и освобождение ресурсов
            </summary>
            <param name="waitForStop">Ожидать остановки</param>
            <param name="letFinishProcess">Позволить обработать всю очередь</param>
            <param name="completeAdding">Запретить добавление новых элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.DynamicThreadPool.Finalize">
            <summary>
            Деструктор
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.DynamicThreadPool.IsWork">
            <summary>
            Работает ли пул
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.DynamicThreadPool.ThreadCount">
            <summary>
            Число активных потоков
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.DynamicThreadPool.MaxThreadCount">
            <summary>
            Максимальное допустимое число потоков
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.DynamicThreadPool.FreeThreadCount">
            <summary>
            Число незанятых потоков
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.DynamicThreadPool.PendingTasksCount">
            <summary>
            Число задач, ожидающих выполнения
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem">
            <summary>
            Единица работы для пула
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem.Act">
            <summary>
            Действие
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem.CapturedContext">
            <summary>
            Захваченный контекст исполнения
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem.#ctor(System.Action)">
            <summary>
            Конструктор ThreadPoolWorkItem
            </summary>
            <param name="act">Действие без параметров</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem.InnerRunJob(System.Object)">
            <summary>
            Выполнение действия без состояния
            </summary>
            <param name="syncContextState">Контекст синхронизации</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem.InnerRunJob(System.Threading.SynchronizationContext)">
            <summary>
            Выполнение действия без состояния
            </summary>
            <param name="syncContext">Контекст синхронизации</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem.RunJob(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Запуск задания
            </summary>
            <param name="customSyncContext">Контекст синхронизации, который нужно установить</param>
            <param name="restoreExecContext">Восстанавливать ли контекст исполнения</param>
        </member>
        <member name="T:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadStartControllingToken">
            <summary>
            Объект контроля запуска потока
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadStartControllingToken.MaxTimeToFailMs">
            <summary>
            Время когда можно считать, что возникла ошибка инициализации и состояние не будет установлено.
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadStartControllingToken.GetTimeMeasureInMs">
            <summary>
            Получить отсчёт времени в миллисекундах
            </summary>
            <returns>Текущее значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadStartControllingToken.SetOk">
            <summary>
            Установить, что инциализация прошла успешно
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadStartControllingToken.SetFail">
            <summary>
            Установить, что возникла ошибка инициализации
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadStartControllingToken.IsInitialized">
            <summary>
            Задано ли значение результата инициализации
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadStartControllingToken.IsOk">
            <summary>
            Прошла ли инициализация успешно
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.ThreadPools.StaticThreadPool">
            <summary>
            Пул потоков с фиксированным числом потоков.
            Тем не менее изменение числа потоков возможно путём явного вызова соостветствующих методов класса.
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.StaticThreadPool.TestThreadRecursion">
            <summary>
            Обнаруживать ли запуск задачи из одного из потоков пула (для предотвращения dead-lock'а)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.ThreadPools.StaticThreadPool._actQueue">
            <summary>
            Очередь задач
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.#ctor(System.Int32,System.Int32,System.Boolean,System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Конструктор StaticThreadPool
            </summary>
            <param name="initialThreadCount">Начальное число потоков в пуле</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
            <param name="isBackground">Использовать ли фоновые потоки</param>
            <param name="name">Имена потоков</param>
            <param name="isRecursiveSync">Разрешение выполнять задачи синхронно в случае рекурсивной постановки</param>
            <param name="useOwnSyncContext">Использовать ли свой контекст синхронизации</param>
            <param name="flowContext">Протаскивать ли контекст исполнения</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.#ctor(System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Конструктор StaticThreadPool
            </summary>
            <param name="initialThreadCount">Начальное число потоков в пуле</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
            <param name="isBackground">Использовать ли фоновые потоки</param>
            <param name="name">Имена потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Конструктор StaticThreadPool
            </summary>
            <param name="initialThreadCount">Начальное число потоков в пуле</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
            <param name="name">Имена потоков</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.#ctor(System.Int32,System.Int32)">
            <summary>
            Конструктор StaticThreadPool
            </summary>
            <param name="initialThreadCount">Начальное число потоков в пуле</param>
            <param name="maxQueueSize">Максимальный размер очереди задач (-1 - не ограничен)</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.#ctor(System.Int32)">
            <summary>
            Конструктор StaticThreadPool
            </summary>
            <param name="initialThreadCount">Начальное число потоков в пуле</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.GetTimeMeasureInMs">
            <summary>
            Получить отсчёт времени в миллисекундах
            </summary>
            <returns>Текущее значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.AddThreads(System.Int32)">
            <summary>
            Увеличить число потоков в пуле
            </summary>
            <param name="count">Число потоков, на которое увеличиваем</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.RemoveThreads(System.Int32)">
            <summary>
            Уменьшить число потоков в пуле
            </summary>
            <param name="count">Число потоков, на которое уменьшаем</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.FillPoolUpTo(System.Int32)">
            <summary>
            Установить count потоков в пуле
            </summary>
            <param name="count">Число потоков, до которого наполняем</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.InitNewThread">
            <summary>
            Создание и запуск нового потока
            </summary>
            <returns>Новый поток</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.RemoveElement(System.Threading.Thread)">
            <summary>
            Удаление потока из пула (предполагается, что поток уже завершился или находится на стадии завершения)
            </summary>
            <param name="elem">Поток</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.ShouldIDie">
            <summary>
            Проверяет, должен ли поток завершится и уменьшает счётчик ожидающих завершение потоков
            </summary>
            <returns>Должен ли завершиться</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.ThreadProc">
            <summary>
            Процедура потока
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.AddWorkItemInner(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Добавление задачи для пула потоков
            </summary>
            <param name="item">Задача</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.TryAddWorkItemInner(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Попытаться добавить задачу в пул потоков
            </summary>
            <param name="item">Задача</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.StopInner(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Внутренняя остановка пула
            </summary>
            <param name="waitForStop">Ожидать остановки</param>
            <param name="letFinishProcess">Позволить обработать всю очередь</param>
            <param name="completeAdding">Запретить добавление новых элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.WaitUntilStop">
            <summary>
            Ожидание полной остановки
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.WaitUntilStop(System.Int32)">
            <summary>
            Ожидание полной остановки с таймаутом
            </summary>
            <param name="timeout">Таймаут ожидания в миллисекундах</param>
            <returns>true - дождались, false - вышли по таймауту</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.Dispose(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Остановка и освобождение ресурсов
            </summary>
            <param name="waitForStop">Ожидать остановки</param>
            <param name="letFinishProcess">Позволить обработать всю очередь</param>
            <param name="completeAdding">Запретить добавление новых элементов</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.Dispose(System.Boolean)">
            <summary>
            Основной код освобождения ресурсов
            </summary>
            <param name="isUserCall">Вызвано ли освобождение пользователем. False - деструктор</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.StaticThreadPool.Finalize">
            <summary>
            Деструктор
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.StaticThreadPool.IsWork">
            <summary>
            Работает ли пул
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.StaticThreadPool.ThreadCount">
            <summary>
            Число активных потоков
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.StaticThreadPool.PendingTasksCount">
            <summary>
            Число задач, ожидающих выполнения
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.ThreadPools.SystemThreadPool">
            <summary>
            Системный пул потоков
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.SystemThreadPool.RunAction(System.Object)">
            <summary>
            Выполнение действия переданного как состояние
            </summary>
            <param name="act">Действие</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.SystemThreadPool.AddWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Добавление задачи для пула потоков
            </summary>
            <param name="item">Задача</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.SystemThreadPool.TryAddWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>
            Попытаться добавить задачу в пул потоков
            </summary>
            <param name="item">Задача</param>
            <returns>Успешность</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.SystemThreadPool.Core#ServiceClasses#AsyncAwaitSupport#IContextSwitchSupplier#Run(System.Action,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.SystemThreadPool.Core#ServiceClasses#AsyncAwaitSupport#IContextSwitchSupplier#RunWithState(System.Action{System.Object},System.Object,System.Boolean)">
            <summary>
            Запустить в другом контексте
            </summary>
            <param name="act">Действие</param>
            <param name="state">Состояние</param>
            <param name="flowContext">Протаскивать ли ExecutionContext</param>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.SystemThreadPool.SwitchToPool">
            <summary>
            Переход на выполнение в пуле посредством await
            </summary>
            <returns>Объект смены контекста выполнения</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.SystemThreadPool.RunAsTask(System.Action)">
            <summary>
            Запуск действия с обёртыванием в Task
            </summary>
            <param name="act">Действие</param>
            <returns>Task</returns>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.SystemThreadPool.RunAsTask``1(System.Func{``0})">
            <summary>
            Запуск функции с обёртыванием в Task
            </summary>
            <typeparam name="T">Тип результата</typeparam>
            <param name="fnc">Функций</param>
            <returns>Task</returns>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.SystemThreadPool.MaxThreadCount">
            <summary>
            Максимальное количество потоков в пуле
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.ThreadPools.SystemThreadPool.MinThreadCount">
            <summary>
            Минимальное количество потоков в пуле
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.ThreadPools.ThreadPoolBaseCodeContractCheck">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBaseCodeContractCheck.#ctor">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBaseCodeContractCheck.AddWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>Контракты</summary>
        </member>
        <member name="M:Core.ServiceClasses.ThreadPools.ThreadPoolBaseCodeContractCheck.TryAddWorkItem(Core.ServiceClasses.ThreadPools.ServiceStuff.ThreadPoolWorkItem)">
            <summary>Контракты</summary>
        </member>
        <member name="T:System.TypeExtensions">
            <summary>
            Расширения для Type
            </summary>
        </member>
        <member name="M:System.TypeExtensions.IsAssignableFromNull(System.Type)">
            <summary>
            Можно ли типу присвоить null
            </summary>
            <param name="tp">Тип</param>
            <returns>Можно ли</returns>
        </member>
        <member name="M:System.TypeExtensions.GetCSName(System.Type)">
            <summary>
            Получение имени типа в формате C#
            </summary>
            <param name="type">Тип</param>
            <returns>Имя</returns>
        </member>
        <member name="M:System.TypeExtensions.GetCSFullName(System.Type)">
            <summary>
            Получение полного имени типа в формате C#
            </summary>
            <param name="type">Тип</param>
            <returns>Полное имя</returns>
        </member>
        <member name="T:Core.ServiceClasses.Throttling.CPUThrottleBehavior">
            <summary>
            Логика отсчёта пропуска операций для предотвращения DOS по CPU.
            Усыпляет потоки при превышении допустимого числа операций.
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.Throttling.ThrottleBehavior">
            <summary>
            Логика отсчёта пропуска операций для предотвращения DOS
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.ThrottleBehavior.CreateNotLimited">
            <summary>
            Создать неограниченное поведение
            </summary>
            <returns>Throttling поведение</returns>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.ThrottleBehavior.#ctor(System.Double,System.Int32)">
            <summary>
            Конструктор ThrottleBehavior
            </summary>
            <param name="maxRequestPerSecond">Максимально допустимое число запросов в секунду</param>
            <param name="measurePeriodMs">Период оценки в миллисекундах</param>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.ThrottleBehavior.#ctor(System.Double)">
            <summary>
            Конструктор ThrottleBehavior
            </summary>
            <param name="maxRequestPerSecond">Максимально допустимое число запросов в секунду</param>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.ThrottleBehavior.GetTimeMeasureInMs">
            <summary>
            Получить отсчёт времени в миллисекундах
            </summary>
            <returns>Текущее значение</returns>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.ThrottleBehavior.AddHit">
            <summary>
            Зафиксировать операцию
            </summary>
            <returns>true - операция может быть выполнена, false - нужно проигнорировать операцию</returns>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.ThrottleBehavior.OnThrottle(System.Int32)">
            <summary>
            Вызывается при необходимости пропуска операций
            </summary>
            <param name="restTimeMs">Время, которое осталось до конца периода</param>
        </member>
        <member name="P:Core.ServiceClasses.Throttling.ThrottleBehavior.MaxRequestPerSecond">
            <summary>
            Максимально разрешённое число операций в секунду
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.CPUThrottleBehavior.CreateNotLimited">
            <summary>
            Создать неограниченное поведение
            </summary>
            <returns>Throttling поведение</returns>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.CPUThrottleBehavior.#ctor(System.Double,System.Int32)">
            <summary>
            Конструктор CPUThrottleBehaviour
            </summary>
            <param name="maxRequestPerSecond">Максимально допустимое число запросов в секунду</param>
            <param name="measurePeriodMs">Период оценки в миллисекундах</param>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.CPUThrottleBehavior.#ctor(System.Double)">
            <summary>
            Конструктор CPUThrottleBehaviour
            </summary>
            <param name="maxRequestPerSecond">Максимально допустимое число запросов в секунду</param>
        </member>
        <member name="M:Core.ServiceClasses.Throttling.CPUThrottleBehavior.OnThrottle(System.Int32)">
            <summary>
            Вызывается при необходимости пропуска операций
            </summary>
            <param name="restTimeMs">Время, которое осталось до конца периода</param>
        </member>
        <member name="T:Core.ServiceClasses.WeakEvent.IWeakEventReferenceStorage">
            <summary>
            Интерфейс хранилища ссылки на объект
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.WeakEvent.IWeakEventReferenceStorage.Target">
            <summary>
            Собственно объект
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.WeakEvent.StrongReferenceStorage">
            <summary>
            Жёсткая ссылка на объект (держит GC)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.StrongReferenceStorage.#ctor(System.Object)">
            <summary>
            Конструктор StrongReferenceStorage
            </summary>
            <param name="target">Хранимый объект</param>
        </member>
        <member name="P:Core.ServiceClasses.WeakEvent.StrongReferenceStorage.Target">
            <summary>
            Собственно объект
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.WeakEvent.MulticastWeakDelegate`1">
            <summary>
            Слабо связанное событие
            </summary>
            <typeparam name="T">Тип делегата</typeparam>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.MulticastWeakDelegate`1.Invariant">
            <summary>
            Контракты
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.MulticastWeakDelegate`1.#cctor">
            <summary>
            Статический конструктор для проверки валидности типа T
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.MulticastWeakDelegate`1.#ctor">
            <summary>
            Конструктор MulitcastWeakDelegate
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.MulticastWeakDelegate`1.Add(`0)">
            <summary>
            Подписка на событие
            </summary>
            <param name="reference">Делегат</param>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.MulticastWeakDelegate`1.Remove(`0)">
            <summary>
            Отписка от события
            </summary>
            <param name="reference">Делегат</param>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.MulticastWeakDelegate`1.GetDelegate">
            <summary>
            Получить делегат, содержащий все делегаты для живых объектов
            </summary>
            <returns>Делегат для инициализации события</returns>
        </member>
        <member name="T:Core.ServiceClasses.WeakEvent.WeakDelegate">
            <summary>
            Данные о слабо связанном делегате
            </summary>
        </member>
        <member name="F:Core.ServiceClasses.WeakEvent.WeakDelegate._valueStorage">
            <summary>
            Хранилище ссылки
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.WeakDelegate.GetDelegate">
            <summary>
            Формирование делегата
            </summary>
            <returns>Делегат</returns>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.WeakDelegate.#ctor(System.Delegate)">
            <summary>
            Конструктор WeakDelegate
            </summary>
            <param name="value">Делегат, из которого создаём</param>
        </member>
        <member name="P:Core.ServiceClasses.WeakEvent.WeakDelegate.DelegateType">
            <summary>
            Тип делегата
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.WeakEvent.WeakDelegate.Target">
            <summary>
            Собственно делегат. Может быть null
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.WeakEvent.WeakDelegate.IsStatic">
            <summary>
            Статический ли делегат
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.WeakEvent.WeakDelegate.IsActive">
            <summary>
            Активен ли делегат
            </summary>
        </member>
        <member name="P:Core.ServiceClasses.WeakEvent.WeakDelegate.Method">
            <summary>
            Вызываемый метод
            </summary>
        </member>
        <member name="T:Core.ServiceClasses.WeakEvent.WeakReferenceStorage">
            <summary>
            Хранилище слабой ссылки на объект (не удерживаемой для GC)
            </summary>
        </member>
        <member name="M:Core.ServiceClasses.WeakEvent.WeakReferenceStorage.#ctor(System.Object)">
            <summary>
            Конструктор WeakReferenceStorage
            </summary>
            <param name="reference">Объект</param>
        </member>
        <member name="P:Core.ServiceClasses.WeakEvent.WeakReferenceStorage.Target">
            <summary>
            Собственно объект. Может быть null.
            </summary>
        </member>
    </members>
</doc>
